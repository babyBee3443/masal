// This is an autogenerated file from Firebase Studio.
'use server';

import { revalidatePath } from 'next/cache';
import type { Story, StoryGenre, ScheduledGeneration } from '@/lib/types';
import { 
  addStory as dbAddStory, 
  deleteStoryById as dbDeleteStoryById, 
  updateStory as dbUpdateStory, 
  getStoryById as dbGetStoryById,
  addScheduledGeneration as dbAddScheduledGeneration,
  deleteScheduledGenerationById as dbDeleteScheduledGenerationById,
  updateScheduledGenerationStatus as dbUpdateScheduledGenerationStatus,
  getScheduledGenerationById as dbGetScheduledGenerationById
} from '@/lib/mock-db';
import { generateStory as aiGenerateStory } from '@/ai/flows/generate-story';
import { regenerateAIImage as aiRegenerateAIImage } from '@/ai/flows/generate-image';

export async function publishStoryAction(storyId: string) {
  try {
    const updatedStory = await dbUpdateStory(storyId, { 
      status: 'published', 
      publishedAt: new Date().toISOString(),
      scheduledAtDate: undefined, // Clear schedule on manual publish
      scheduledAtTime: undefined, 
    });
    if (!updatedStory) throw new Error('Hikaye bulunamadı');
    revalidatePath('/');
    revalidatePath('/admin', 'layout'); // Revalidate layout to update lists potentially shown on admin page
    revalidatePath(`/story/${storyId}`);
    revalidatePath(`/categories/${updatedStory.genre}`);
    return { success: true, story: updatedStory };
  } catch (error) {
    console.error("Hikaye yayınlanamadı:", error);
    return { success: false, error: error instanceof Error ? error.message : 'Hikaye yayınlanamadı' };
  }
}

export async function deleteStoryAction(storyId: string) {
  try {
    const deleted = await dbDeleteStoryById(storyId);
    if (!deleted) throw new Error('Hikaye bulunamadı veya zaten silinmiş');
    revalidatePath('/');
    revalidatePath('/admin', 'layout');
    return { success: true };
  } catch (error) {
    console.error("Hikaye silinemedi:", error);
    return { success: false, error: error instanceof Error ? error.message : 'Hikaye silinemedi' };
  }
}

export async function updateStoryCategoryAction(storyId: string, newGenre: StoryGenre) {
  try {
    const oldStory = await dbGetStoryById(storyId);
    if (!oldStory) throw new Error('Hikaye bulunamadı');

    const updatedStory = await dbUpdateStory(storyId, { genre: newGenre });
    if (!updatedStory) throw new Error('Hikaye kategorisi güncellenemedi');
    
    revalidatePath('/admin', 'layout');
    revalidatePath(`/story/${storyId}`);
    revalidatePath(`/categories/${oldStory.genre}`); 
    revalidatePath(`/categories/${newGenre}`);     
    if (oldStory.status === 'published') {
      revalidatePath('/'); 
    }
    return { success: true, story: updatedStory };
  } catch (error) {
    console.error("Hikaye kategorisi güncellenemedi:", error);
    return { success: false, error: error instanceof Error ? error.message : 'Kategori güncellenemedi' };
  }
}

export async function generateNewStoryAction(genre: StoryGenre): Promise<{ success: boolean; story?: Story; error?: string }> {
  try {
    const aiResult = await aiGenerateStory({ genre });
    const newStoryData: Omit<Story, 'id' | 'summary' | 'createdAt'> = {
      title: aiResult.title,
      content: aiResult.content,
      imageUrl: aiResult.imageUrl || 'https://placehold.co/600x480.png',
      genre: genre,
      status: 'pending',
    };
    const savedStory = await dbAddStory(newStoryData);
    revalidatePath('/admin', 'layout');
    return { success: true, story: savedStory };
  } catch (error) {
    console.error("Yeni hikaye oluşturulamadı:", error);
    return { success: false, error: error instanceof Error ? error.message : 'Yapay zeka ile hikaye oluşturulamadı' };
  }
}

export async function regenerateStoryImageAction(storyId: string, storyText: string): Promise<{ success: boolean; imageUrl?: string; error?: string }> {
  try {
    const aiResult = await aiRegenerateAIImage({ storyText });
    if (!aiResult.imageUrl) {
      throw new Error('Yapay zeka yeni bir görsel URLsi oluşturamadı.');
    }
    const updatedStory = await dbUpdateStory(storyId, { imageUrl: aiResult.imageUrl });
    if (!updatedStory) throw new Error('Görsel güncellemesi için hikaye bulunamadı');
    
    revalidatePath('/admin', 'layout');
    revalidatePath(`/story/${storyId}`);
    if (updatedStory.status === 'published') {
      revalidatePath('/');
      revalidatePath(`/categories/${updatedStory.genre}`);
    }
    return { success: true, imageUrl: aiResult.imageUrl };
  } catch (error) {
    console.error("Görsel yeniden oluşturulamadı:", error);
    return { success: false, error: error instanceof Error ? error.message : 'Görsel yeniden oluşturulamadı' };
  }
}

export async function scheduleStoryPublicationAction(storyId: string, date: string, time: string): Promise<{ success: boolean; story?: Story; error?: string }> {
  try {
    const story = await dbGetStoryById(storyId);
    if (!story) {
      return { success: false, error: "Hikaye bulunamadı." };
    }
    if (story.status === 'published') {
      return { success: false, error: "Yayınlanmış hikayeler tekrar zamanlanamaz." };
    }
    const updatedStory = await dbUpdateStory(storyId, { scheduledAtDate: date, scheduledAtTime: time });
    if (!updatedStory) {
      return { success: false, error: "Hikaye zamanlanamadı." };
    }
    revalidatePath('/admin', 'layout');
    return { success: true, story: updatedStory };
  } catch (e) {
    const error = e instanceof Error ? e.message : "Bilinmeyen bir hata oluştu.";
    return { success: false, error };
  }
}

// Actions for Scheduled Story Generation
export async function scheduleStoryGenerationAction(scheduledDate: string, scheduledTime: string, genre: StoryGenre): Promise<{ success: boolean; scheduledGeneration?: ScheduledGeneration; error?: string }> {
  try {
    if (!scheduledDate || !scheduledTime || !genre) {
      return { success: false, error: "Lütfen tarih, saat ve tür bilgilerini eksiksiz girin." };
    }
    const newScheduledItem = await dbAddScheduledGeneration({ scheduledDate, scheduledTime, genre });
    revalidatePath('/admin/scheduling');
    return { success: true, scheduledGeneration: newScheduledItem };
  } catch (e) {
    const error = e instanceof Error ? e.message : "Planlama sırasında bir hata oluştu.";
    return { success: false, error };
  }
}

export async function processScheduledGenerationAction(id: string): Promise<{ success: boolean; story?: Story; error?: string }> {
  try {
    const scheduledItem = await dbGetScheduledGenerationById(id);
    if (!scheduledItem) {
      return { success: false, error: "Planlanmış üretim bulunamadı." };
    }
    if (scheduledItem.status === 'generated') {
      return { success: false, error: "Bu üretim zaten tamamlanmış." };
    }

    const generationResult = await generateNewStoryAction(scheduledItem.genre);

    if (generationResult.success && generationResult.story) {
      await dbUpdateScheduledGenerationStatus(id, 'generated', generationResult.story.id);
      revalidatePath('/admin/scheduling');
      revalidatePath('/admin', 'layout'); // To update main admin story list
      return { success: true, story: generationResult.story };
    } else {
      await dbUpdateScheduledGenerationStatus(id, 'failed', undefined, generationResult.error || "Hikaye üretilemedi.");
      revalidatePath('/admin/scheduling');
      return { success: false, error: generationResult.error || "Hikaye üretilemedi." };
    }
  } catch (e) {
    const error = e instanceof Error ? e.message : "Planlanmış üretim işlenirken bir hata oluştu.";
    await dbUpdateScheduledGenerationStatus(id, 'failed', undefined, error);
    revalidatePath('/admin/scheduling');
    return { success: false, error };
  }
}

export async function deleteScheduledGenerationAction(id: string): Promise<{ success: boolean; error?: string }> {
  try {
    const deleted = await dbDeleteScheduledGenerationById(id);
    if (!deleted) {
      return { success: false, error: "Planlanmış üretim bulunamadı veya silinemedi." };
    }
    revalidatePath('/admin/scheduling');
    return { success: true };
  } catch (e) {
    const error = e instanceof Error ? e.message : "Silme işlemi sırasında bir hata oluştu.";
    return { success: false, error };
  }
}

