
// This is an autogenerated file from Firebase Studio.
'use client';

import { useState, useTransition, useEffect } from 'react';
import Image from 'next/image';
import type { Story, StoryGenre } from '@/lib/types';
import { GENRES } from '@/lib/constants';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Textarea } from '@/components/ui/textarea';
import { Input } from '@/components/ui/input';
import { Calendar } from '@/components/ui/calendar';
import { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';
import { useToast } from '@/hooks/use-toast';
import { 
    publishStoryAction, 
    deleteStoryAction, 
    updateStoryCategoryAction, 
    regenerateStoryImageAction, 
    scheduleStoryPublicationAction 
} from '@/lib/actions';
import { CheckCircle, Trash2, RefreshCw, Loader2, CalendarClock, Edit3 } from 'lucide-react'; // Changed Edit to Edit3
import { format, parseISO, isValid } from 'date-fns';
import { tr } from 'date-fns/locale';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
  DialogClose,
} from "@/components/ui/dialog";
import { Label } from '@/components/ui/label';


interface AdminStoryControlsProps {
  story: Story;
  onStoryUpdate: () => void; // Callback to inform parent to refresh list
}

export function AdminStoryControls({ story: initialStory, onStoryUpdate }: AdminStoryControlsProps) {
  const [story, setStory] = useState(initialStory);
  const [isProcessing, startTransition] = useTransition(); // Renamed for clarity
  const { toast } = useToast();

  const [isSchedulingDialogOpen, setIsSchedulingDialogOpen] = useState(false);
  const [scheduledDate, setScheduledDate] = useState<Date | undefined>(
    initialStory.scheduledAtDate && isValid(parseISO(initialStory.scheduledAtDate)) ? parseISO(initialStory.scheduledAtDate) : undefined
  );
  const [scheduledTime, setScheduledTime] = useState<string>(initialStory.scheduledAtTime || "10:00");
  
  const [isEditing, setIsEditing] = useState(false);
  const [editableTitle, setEditableTitle] = useState(initialStory.title);
  const [editableContent, setEditableContent] = useState(initialStory.content);


  useEffect(() => {
    setStory(initialStory);
    setScheduledDate(initialStory.scheduledAtDate && isValid(parseISO(initialStory.scheduledAtDate)) ? parseISO(initialStory.scheduledAtDate) : undefined);
    setScheduledTime(initialStory.scheduledAtTime || "10:00");
    setEditableTitle(initialStory.title);
    setEditableContent(initialStory.content);
    setIsEditing(false); // Reset editing state when story prop changes
  }, [initialStory]);


  const handlePublish = () => {
    startTransition(async () => {
      const result = await publishStoryAction(story.id);
      if (result.success && result.story) {
        // setStory(result.story); // Parent will update via onStoryUpdate
        toast({ title: 'Hikaye Yayınlandı', description: `"${result.story.title}" artık yayında.` });
        onStoryUpdate(); 
      } else {
        toast({ variant: 'destructive', title: 'Yayınlama Hatası', description: result.error });
      }
    });
  };

  const handleDelete = () => {
    startTransition(async () => {
      const result = await deleteStoryAction(story.id);
      if (result.success) {
        toast({ title: 'Hikaye Silindi', description: `"${story.title}" silindi.` });
        onStoryUpdate(); 
      } else {
        toast({ variant: 'destructive', title: 'Silme Hatası', description: result.error });
      }
    });
  };

  const handleCategoryChange = (newGenre: StoryGenre) => {
    startTransition(async () => {
      const result = await updateStoryCategoryAction(story.id, newGenre);
      if (result.success && result.story) {
        // setStory(result.story);
        toast({ title: 'Kategori Güncellendi', description: `"${result.story.title}" hikayesinin kategorisi ${newGenre} olarak değiştirildi.` });
        onStoryUpdate();
      } else {
        toast({ variant: 'destructive', title: 'Kategori Güncelleme Hatası', description: result.error });
      }
    });
  };

  const handleRegenerateImage = () => {
    startTransition(async () => {
      toast({title: "Görsel Oluşturuluyor", description: "Yapay zeka yeni bir görsel hazırlıyor..."});
      const result = await regenerateStoryImageAction(story.id, story.content);
      if (result.success && result.imageUrl) {
        // setStory(prev => ({ ...prev, imageUrl: result.imageUrl! }));
        toast({ title: 'Görsel Yeniden Oluşturuldu', description: `"${story.title}" için yeni görsel oluşturuldu.` });
        onStoryUpdate(); 
      } else {
        toast({ variant: 'destructive', title: 'Görsel Yeniden Oluşturma Hatası', description: result.error });
      }
    });
  };

  const handleSchedulePublication = () => {
    if (!scheduledDate || !scheduledTime) {
      toast({ variant: 'destructive', title: 'Zamanlama Hatası', description: 'Lütfen geçerli bir tarih ve saat seçin.' });
      return;
    }
    const dateString = format(scheduledDate, 'yyyy-MM-dd');
    startTransition(async () => {
      const result = await scheduleStoryPublicationAction(story.id, dateString, scheduledTime);
      if (result.success && result.story) {
        // setStory(result.story);
        toast({ title: 'Hikaye Zamanlandı', description: `"${result.story.title}" ${format(scheduledDate, 'dd MMMM yyyy', {locale: tr})} ${scheduledTime} için zamanlandı.`});
        setIsSchedulingDialogOpen(false);
        onStoryUpdate();
      } else {
        toast({ variant: 'destructive', title: 'Zamanlama Hatası', description: result.error });
      }
    });
  };
  
  const handleSaveEdits = () => {
    startTransition(async () => {
        // In a real app, this would call an action like updateStoryDetailsAction
        // For now, we simulate by calling onStoryUpdate which should refetch from localStorage
        // where the story content would have been "updated" by direct state change if using a library like Zustand
        // With direct localStorage, we need an action that calls dbUpdateStory
        // Let's assume an action `updateStoryDetailsAction(storyId, { title, content })` exists or add it
        // For now, let's try to make this work with existing onStoryUpdate, assuming it refetches
        // This is a temporary solution until a proper update action is implemented.
        // This won't actually save to localStorage without an action.
        // We need to call an action to update the story in mock-db.ts (localStorage)
        const { updateStory } = await import('@/lib/mock-db'); // Dynamically import to use client-side
        const updatedStory = await updateStory(story.id, { title: editableTitle, content: editableContent });

        if (updatedStory) {
            toast({ title: "Hikaye Güncellendi", description: `"${updatedStory.title}" başarıyla güncellendi.`});
            setIsEditing(false);
            onStoryUpdate(); // This will trigger re-fetch from localStorage
        } else {
            toast({ variant: "destructive", title: "Güncelleme Başarısız", description: "Hikaye güncellenemedi."});
        }
    });
  };


  const formatDateDisplay = (dateString?: string, timeString?: string) => {
    if (!dateString) return 'Zamanlanmamış';
    try {
      if(!isValid(parseISO(dateString))) return 'Geçersiz Tarih Yapısı';
      const date = parseISO(dateString);
      let formatted = format(date, 'dd MMMM yyyy', { locale: tr });
      if (timeString) {
        const timeParts = timeString.split(':');
        if (timeParts.length === 2 && timeParts[0].length <= 2 && timeParts[1].length <= 2) {
            const hours = timeParts[0].padStart(2, '0');
            const minutes = timeParts[1].padStart(2, '0');
            formatted += ` ${hours}:${minutes}`;
        } else {
            formatted += ` ${timeString}`; 
        }
      }
      return formatted;
    } catch (e) {
      console.error("AdminStoryControls - Tarih formatlama hatası:", e, dateString, timeString);
      return 'Hatalı Tarih';
    }
  }
  
  const formatSimpleDate = (dateString?: string) => {
    if (!dateString) return 'N/A';
    try {
      if(!isValid(parseISO(dateString))) return 'Geçersiz Tarih Yapısı';
      const date = parseISO(dateString);
      return format(date, 'dd MMMM yyyy, HH:mm', {locale: tr});
    } catch (e) {
       console.warn("AdminStoryControls - formatSimpleDate fallback parse for:", dateString, e);
       try {
           const parsedDate = new Date(dateString); // Fallback parsing
           if(isValid(parsedDate)) {
            return format(parsedDate, 'dd MMMM yyyy, HH:mm', {locale: tr});
           }
           return 'Hatalı Tarih';
       } catch (finalError) {
            return 'Çok Hatalı Tarih';
       }
    }
  }


  return (
    <Card className="w-full shadow-lg animate-fadeIn">
      <CardHeader>
        {isEditing ? (
            <Input 
                value={editableTitle} 
                onChange={(e) => setEditableTitle(e.target.value)}
                className="text-2xl font-bold mb-2"
                disabled={isProcessing}
            />
        ) : (
            <CardTitle className="text-2xl">{story.title}</CardTitle>
        )}
        <CardDescription>
          Durum: <span className={`font-semibold ${story.status === 'published' ? 'text-green-600' : 'text-orange-500'}`}>{story.status === 'published' ? 'Yayınlandı' : 'Beklemede'}</span>
          <span className="mx-2">|</span>
          Tür: {story.genre}
          <br />
          Oluşturulma: {formatSimpleDate(story.createdAt)}
          {story.status === 'published' && story.publishedAt && (
            <> | Yayınlanma: {formatSimpleDate(story.publishedAt)}</>
          )}
           {story.status === 'pending' && story.scheduledAtDate && (
            <> | Planlanan Yayın: <span className="font-semibold text-blue-600">{formatDateDisplay(story.scheduledAtDate, story.scheduledAtTime)}</span></>
          )}
        </CardDescription>
      </CardHeader>
      <CardContent className="grid md:grid-cols-3 gap-6">
        <div className="md:col-span-1">
           <Image
            src={story.imageUrl || `https://placehold.co/600x480.png`}
            alt={`${story.title} için görsel`}
            width={600}
            height={480}
            className="rounded-lg object-cover w-full aspect-[4/3] shadow-md"
            data-ai-hint="story illustration fantasy"
            key={story.imageUrl} // Add key to force re-render on image URL change
          />
          <Button onClick={handleRegenerateImage} disabled={isProcessing} className="w-full mt-4" variant="outline">
            {isProcessing && story.imageUrl !== initialStory.imageUrl ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <RefreshCw className="mr-2 h-4 w-4" />}
            Görseli Yeniden Oluştur
          </Button>
        </div>
        <div className="md:col-span-2 space-y-4">
          <div>
            <Label htmlFor={`summary-${story.id}`} className="text-sm font-medium text-muted-foreground block mb-1">Özet (Otomatik)</Label>
             <Textarea
                id={`summary-${story.id}`}
                value={story.summary}
                readOnly
                className="h-24 bg-muted/50"
              />
          </div>
           <div>
            <Label htmlFor={`content-${story.id}`} className="text-sm font-medium text-muted-foreground block mb-1">Tam İçerik</Label>
             <Textarea
                id={`content-${story.id}`}
                value={isEditing ? editableContent : story.content}
                readOnly={!isEditing || isProcessing}
                onChange={isEditing ? (e) => setEditableContent(e.target.value) : undefined}
                className={`h-40 ${isEditing ? 'bg-background' : 'bg-muted/50'}`}
              />
          </div>
          <div>
            <Label htmlFor={`category-${story.id}`} className="text-sm font-medium text-muted-foreground block mb-1">Kategoriyi Değiştir</Label>
            <Select value={story.genre} onValueChange={(value) => handleCategoryChange(value as StoryGenre)} disabled={isProcessing || isEditing}>
              <SelectTrigger id={`category-${story.id}`} className="w-full">
                <SelectValue placeholder="Tür seçin" />
              </SelectTrigger>
              <SelectContent>
                {GENRES.map(g => <SelectItem key={g} value={g}>{g}</SelectItem>)}
              </SelectContent>
            </Select>
          </div>
        </div>
      </CardContent>
      <CardFooter className="flex flex-wrap justify-between items-center gap-2">
        <div>
        {isEditing ? (
            <div className="flex gap-2">
                <Button onClick={handleSaveEdits} disabled={isProcessing} variant="default">
                    {isProcessing ? <Loader2 className="h-4 w-4 animate-spin" /> : <CheckCircle className="h-4 w-4"/>} Kaydet
                </Button>
                <Button onClick={() => { setIsEditing(false); setEditableTitle(story.title); setEditableContent(story.content);}} variant="outline" disabled={isProcessing}>
                    İptal
                </Button>
            </div>
        ) : (
             <Button onClick={() => setIsEditing(true)} variant="outline" disabled={isProcessing || story.status === 'published'}>
                <Edit3 className="mr-2 h-4 w-4" /> Düzenle
            </Button>
        )}
        </div>

        <div className="flex flex-wrap justify-end space-x-3 gap-y-2">
            {story.status === 'pending' && !isEditing && (
            <>
                <Button onClick={handlePublish} disabled={isProcessing} className="bg-green-600 hover:bg-green-700 text-white">
                {isProcessing && story.status !== 'pending' && story.status === 'published' ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <CheckCircle className="mr-2 h-4 w-4" />}
                Şimdi Yayınla
                </Button>
                <Dialog open={isSchedulingDialogOpen} onOpenChange={setIsSchedulingDialogOpen}>
                <DialogTrigger asChild>
                    <Button variant="outline" disabled={isProcessing}>
                    <CalendarClock className="mr-2 h-4 w-4" />
                    {story.scheduledAtDate ? 'Zamanlamayı Düzenle' : 'Yayın Zamanla'}
                    </Button>
                </DialogTrigger>
                <DialogContent className="sm:max-w-[425px]">
                    <DialogHeader>
                    <DialogTitle>Hikaye Yayınını Zamanla</DialogTitle>
                    <DialogDescription>
                        "{story.title}" hikayesinin ne zaman yayınlanacağını seçin.
                    </DialogDescription>
                    </DialogHeader>
                    <div className="grid gap-4 py-4">
                    <div className="grid grid-cols-4 items-center gap-4">
                        <Label htmlFor="schedule-date" className="text-right">
                        Tarih
                        </Label>
                        <Popover>
                        <PopoverTrigger asChild>
                            <Button
                            variant={"outline"}
                            className={`col-span-3 justify-start text-left font-normal ${!scheduledDate && "text-muted-foreground"}`}
                            >
                            <CalendarClock className="mr-2 h-4 w-4" />
                            {scheduledDate ? format(scheduledDate, "PPP", {locale: tr}) : <span>Bir tarih seçin</span>}
                            </Button>
                        </PopoverTrigger>
                        <PopoverContent className="w-auto p-0">
                            <Calendar
                            mode="single"
                            selected={scheduledDate}
                            onSelect={setScheduledDate}
                            initialFocus
                            locale={tr}
                            disabled={(date) => date < new Date(new Date().setHours(0,0,0,0))} 
                            />
                        </PopoverContent>
                        </Popover>
                    </div>
                    <div className="grid grid-cols-4 items-center gap-4">
                        <Label htmlFor="schedule-time" className="text-right">
                        Saat
                        </Label>
                        <Input
                        id="schedule-time"
                        type="time"
                        value={scheduledTime}
                        onChange={(e) => setScheduledTime(e.target.value)}
                        className="col-span-3"
                        />
                    </div>
                    </div>
                    <DialogFooter>
                    <DialogClose asChild><Button variant="outline">İptal</Button></DialogClose>
                    <Button onClick={handleSchedulePublication} disabled={isProcessing || !scheduledDate || !scheduledTime}>
                        {isProcessing && story.scheduledAtDate ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : null}
                        Zamanla
                    </Button>
                    </DialogFooter>
                </DialogContent>
                </Dialog>
            </>
            )}
            {!isEditing && (
                 <AlertDialog>
                    <AlertDialogTrigger asChild>
                        <Button variant="destructive" disabled={isProcessing}>
                        {isProcessing && !initialStory.status /* Check against initialStory as story might be optimistic update */ ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <Trash2 className="mr-2 h-4 w-4" />}
                        Sil
                        </Button>
                    </AlertDialogTrigger>
                    <AlertDialogContent>
                        <AlertDialogHeader>
                        <AlertDialogTitle>Bu hikayeyi silmek istediğinize emin misiniz?</AlertDialogTitle>
                        <AlertDialogDescription>
                            Bu işlem geri alınamaz. Bu, "{story.title}" başlıklı hikayeyi kalıcı olarak silecek.
                        </AlertDialogDescription>
                        </AlertDialogHeader>
                        <AlertDialogFooter>
                        <AlertDialogCancel>İptal</AlertDialogCancel>
                        <AlertDialogAction onClick={handleDelete} className="bg-destructive hover:bg-destructive/90">
                            Evet, hikayeyi sil
                        </AlertDialogAction>
                        </AlertDialogFooter>
                    </AlertDialogContent>
                </AlertDialog>
            )}
           
        </div>
      </CardFooter>
    </Card>
  );
}

    