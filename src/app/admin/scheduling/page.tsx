
// This is an autogenerated file from Firebase Studio.
'use client';

import { useEffect, useState, useTransition } from 'react';
import Link from 'next/link';
import type { ScheduledGeneration, StoryGenre } from '@/lib/types';
import { getScheduledGenerations } from '@/lib/mock-db';
import { GENRES } from '@/lib/constants';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Input } from '@/components/ui/input';
import { Calendar } from '@/components/ui/calendar';
import { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';
import { useToast } from '@/hooks/use-toast';
import { scheduleStoryGenerationAction, processScheduledGenerationAction, deleteScheduledGenerationAction } from '@/lib/actions';
import { Loader2, AlertTriangle, CalendarPlus, CalendarClock, Trash2, Wand2, CheckCircle, XCircle, Info, CalendarCheck2, RefreshCw } from 'lucide-react';
import { format, parseISO, isValid } from 'date-fns';
import { tr } from 'date-fns/locale';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog";
import { Label } from '@/components/ui/label';
import { Badge } from '@/components/ui/badge';
import { Separator } from '@/components/ui/separator';

export default function SchedulingPage() {
  const [scheduledGenerations, setScheduledGenerations] = useState<ScheduledGeneration[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [isTransitioning, startTransition] = useTransition();
  const { toast } = useToast();

  const [newScheduleDate, setNewScheduleDate] = useState<Date | undefined>(new Date());
  const [newScheduleTime, setNewScheduleTime] = useState<string>("10:00");
  const [newScheduleGenre, setNewScheduleGenre] = useState<StoryGenre | undefined>(undefined);
  
  // Flag to track if initial auto-processing has been attempted for the current session/load
  const [autoProcessingAttempted, setAutoProcessingAttempted] = useState(false);


  const fetchScheduledItems = async (isManualRefresh = false) => {
    setIsLoading(true);
    setError(null);
    try {
      let items = await getScheduledGenerations();
      const now = new Date();
      const dueItems = items.filter(item => {
        if (item.status !== 'pending') return false;
        try {
          const scheduledDateTime = parseISO(`${item.scheduledDate}T${item.scheduledTime}`);
          return isValid(scheduledDateTime) && scheduledDateTime <= now;
        } catch (e) {
          console.error("Error parsing scheduled date/time for item:", item.id, e);
          return false; 
        }
      });

      if (dueItems.length > 0 && (isManualRefresh || !autoProcessingAttempted)) {
        if (!autoProcessingAttempted) { // Set flag only once per page load unless manually refreshed
          setAutoProcessingAttempted(true);
        }
        
        toast({
          title: "Otomatik Üretim Kontrolü",
          description: `${dueItems.length} adet zamanı gelmiş planlı üretim işleniyor...`,
          duration: 5000,
        });

        const processingPromises = dueItems.map(async (item) => {
          try {
            const result = await processScheduledGenerationAction(item.id);
            if (result.success && result.story) {
              toast({
                variant: "default",
                title: "Otomatik Hikaye Üretildi!",
                description: `"${result.story.title}" (${item.genre}) zamanlandığı gibi başarıyla oluşturuldu.`,
              });
            } else {
              toast({
                variant: "destructive",
                title: "Otomatik Üretim Başarısız",
                description: `${item.genre} türündeki zamanlanmış hikaye üretilemedi: ${result.error}`,
              });
            }
          } catch (e) {
             toast({
                variant: "destructive",
                title: "Otomatik Üretim Hatası",
                description: `${item.genre} türündeki zamanlanmış hikaye işlenirken bir hata oluştu: ${e instanceof Error ? e.message : String(e)}`,
              });
          }
        });
        await Promise.all(processingPromises);
        
        items = await getScheduledGenerations(); // Refetch to get updated statuses
      }
      
      setScheduledGenerations(items);
    } catch (e) {
      setError(e instanceof Error ? e.message : 'Planlanmış üretimler yüklenemedi.');
      console.error(e);
    } finally {
      setIsLoading(false);
    }
  };
  
  useEffect(() => {
    // Initial fetch on component mount. Pass false for isManualRefresh.
    // Auto-processing will be triggered if conditions are met.
    fetchScheduledItems(false); 
  }, []); // Empty dependency array ensures this runs once on mount

  const handleAddScheduledGeneration = () => {
    if (!newScheduleDate || !newScheduleTime || !newScheduleGenre) {
      toast({ variant: 'destructive', title: 'Eksik Bilgi', description: 'Lütfen tarih, saat ve tür seçin.' });
      return;
    }
    const dateString = format(newScheduleDate, 'yyyy-MM-dd');
    startTransition(async () => {
      const result = await scheduleStoryGenerationAction(dateString, newScheduleTime, newScheduleGenre);
      if (result.success && result.scheduledGeneration) {
        toast({ title: 'Hikaye Üretimi Planlandı', description: `${result.scheduledGeneration.genre} türünde hikaye ${formatDateDisplay(result.scheduledGeneration.scheduledDate, result.scheduledGeneration.scheduledTime)} için planlandı.` });
        fetchScheduledItems(false); // Refresh list, don't treat as manual refresh for auto-processing
        setNewScheduleDate(new Date());
        setNewScheduleTime("10:00");
        setNewScheduleGenre(undefined);
      } else {
        toast({ variant: 'destructive', title: 'Planlama Başarısız', description: result.error });
      }
    });
  };

  const handleProcessGeneration = (id: string) => {
    startTransition(async () => {
      const result = await processScheduledGenerationAction(id);
      if (result.success && result.story) {
        toast({ title: 'Hikaye Üretildi!', description: `"${result.story.title}" başarıyla oluşturuldu.` });
      } else {
        toast({ variant: 'destructive', title: 'Üretim Başarısız', description: result.error });
      }
      fetchScheduledItems(false); // Refresh list
    });
  };

  const handleDeleteGeneration = (id: string, genre: StoryGenre, date: string, time: string) => {
    startTransition(async () => {
      const result = await deleteScheduledGenerationAction(id);
      if (result.success) {
        toast({ title: 'Plan Silindi', description: `${genre} türündeki ${formatDateDisplay(date, time)} tarihli plan silindi.` });
        fetchScheduledItems(false); // Refresh list
      } else {
        toast({ variant: 'destructive', title: 'Silme Başarısız', description: result.error });
      }
    });
  };

  const formatDateDisplay = (dateString?: string, timeString?: string) => {
    if (!dateString) return 'N/A';
    try {
      const date = parseISO(dateString);
      if (!isValid(date)) return 'Geçersiz Tarih';
      let formatted = format(date, 'dd MMMM yyyy', { locale: tr });
      if (timeString) {
        formatted += `, ${timeString}`;
      }
      return formatted;
    } catch (e) {
      console.error("Tarih formatlama hatası:", e, dateString, timeString);
      return 'Hatalı Tarih';
    }
  };

  const getStatusBadge = (status: ScheduledGeneration['status']) => {
    switch (status) {
      case 'pending':
        return <Badge variant="outline" className="bg-yellow-100 text-yellow-700 border-yellow-300"><CalendarClock className="mr-1 h-3 w-3" />Beklemede</Badge>;
      case 'generated':
        return <Badge variant="outline" className="bg-green-100 text-green-700 border-green-300"><CheckCircle className="mr-1 h-3 w-3" />Üretildi</Badge>;
      case 'failed':
        return <Badge variant="destructive"><XCircle className="mr-1 h-3 w-3" />Başarısız</Badge>;
      default:
        return <Badge variant="secondary">Bilinmiyor</Badge>;
    }
  };
  
  if (isLoading && scheduledGenerations.length === 0 && !autoProcessingAttempted) { // Show initial loading only before first processing attempt
    return (
      <div className="flex justify-center items-center min-h-[calc(100vh-200px)]">
        <Loader2 className="h-12 w-12 animate-spin text-primary" />
        <p className="ml-4 text-lg text-muted-foreground">Planlar yükleniyor...</p>
      </div>
    );
  }

  if (error) {
    return (
      <div className="text-center py-10 text-red-600 bg-red-50 p-6 rounded-lg shadow-md">
        <AlertTriangle className="mx-auto h-12 w-12 mb-4" />
        <h2 className="text-2xl font-semibold mb-2">Planlar Yüklenirken Hata Oluştu</h2>
        <p>{error}</p>
        <Button onClick={() => fetchScheduledItems(true)} variant="destructive" className="mt-4">
          <RefreshCw className="mr-2 h-4 w-4" /> Tekrar Dene
        </Button>
      </div>
    );
  }

  return (
    <div className="space-y-8">
      <div className="flex flex-col sm:flex-row justify-between items-center gap-4">
        <h1 className="text-3xl md:text-4xl font-bold text-foreground tracking-tight">Hikaye Üretim Planlayıcısı</h1>
        <Button variant="outline" asChild>
          <Link href="/admin">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="mr-2 h-4 w-4"><path d="m12 19-7-7 7-7"/><path d="M19 12H5"/></svg>
            Admin Paneline Dön
          </Link>
        </Button>
      </div>

      <Card className="shadow-lg">
        <CardHeader>
          <CardTitle className="text-2xl flex items-center">
            <CalendarPlus className="mr-3 h-7 w-7 text-primary" />
            Yeni Hikaye Üretimi Planla
          </CardTitle>
          <CardDescription>Belirli bir tarih, saat ve tür için otomatik hikaye üretimi planlayın.</CardDescription>
        </CardHeader>
        <CardContent className="space-y-6">
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4 items-end">
            <div>
              <Label htmlFor="new-schedule-date" className="block mb-1 font-medium">Tarih</Label>
              <Popover>
                <PopoverTrigger asChild>
                  <Button
                    id="new-schedule-date"
                    variant={"outline"}
                    className={`w-full justify-start text-left font-normal ${!newScheduleDate && "text-muted-foreground"}`}
                  >
                    <CalendarClock className="mr-2 h-4 w-4" />
                    {newScheduleDate ? format(newScheduleDate, "PPP", { locale: tr }) : <span>Bir tarih seçin</span>}
                  </Button>
                </PopoverTrigger>
                <PopoverContent className="w-auto p-0">
                  <Calendar
                    mode="single"
                    selected={newScheduleDate}
                    onSelect={setNewScheduleDate}
                    initialFocus
                    locale={tr}
                    disabled={(date) => date < new Date(new Date().setHours(0,0,0,0))} 
                  />
                </PopoverContent>
              </Popover>
            </div>
            <div>
              <Label htmlFor="new-schedule-time" className="block mb-1 font-medium">Saat</Label>
              <Input
                id="new-schedule-time"
                type="time"
                value={newScheduleTime}
                onChange={(e) => setNewScheduleTime(e.target.value)}
                className="w-full"
              />
            </div>
            <div>
              <Label htmlFor="new-schedule-genre" className="block mb-1 font-medium">Tür</Label>
              <Select value={newScheduleGenre} onValueChange={(value) => setNewScheduleGenre(value as StoryGenre)}>
                <SelectTrigger id="new-schedule-genre" className="w-full">
                  <SelectValue placeholder="Bir tür seçin..." />
                </SelectTrigger>
                <SelectContent>
                  {GENRES.map(g => <SelectItem key={g} value={g}>{g}</SelectItem>)}
                </SelectContent>
              </Select>
            </div>
          </div>
          <Button onClick={handleAddScheduledGeneration} disabled={isTransitioning || !newScheduleDate || !newScheduleTime || !newScheduleGenre} className="w-full md:w-auto">
            {isTransitioning ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <CalendarCheck2 className="mr-2 h-4 w-4" />}
            Üretimi Planla
          </Button>
        </CardContent>
      </Card>

      <Separator className="my-8" />

      <h2 className="text-2xl md:text-3xl font-semibold text-foreground tracking-tight mb-6">
        Planlanmış Üretimler ({scheduledGenerations.length})
        <Button onClick={() => fetchScheduledItems(true)} variant="ghost" size="icon" className="ml-2" disabled={isTransitioning || isLoading}>
            <RefreshCw className={`h-5 w-5 ${(isTransitioning || isLoading) ? 'animate-spin' : ''}`} />
        </Button>
      </h2>
      {scheduledGenerations.length === 0 && !isLoading ? (
        <div className="text-center py-10 text-muted-foreground bg-card p-6 rounded-lg shadow">
          <Info className="mx-auto h-12 w-12 mb-4" />
          <p className="text-lg">Henüz planlanmış bir hikaye üretimi yok.</p>
          <p>Yukarıdaki formu kullanarak yeni üretimler planlayabilirsiniz.</p>
        </div>
      ) : (
        <div className="space-y-4">
          {scheduledGenerations.map(item => (
            <Card key={item.id} className="shadow-md hover:shadow-lg transition-shadow">
              <CardHeader>
                <CardTitle className="flex justify-between items-center">
                  <span>{item.genre} Türünde Hikaye</span>
                  {getStatusBadge(item.status)}
                </CardTitle>
                <CardDescription>
                  Planlanan Zaman: {formatDateDisplay(item.scheduledDate, item.scheduledTime)}
                  <br/>
                  Oluşturulma Tarihi: {formatDateDisplay(item.createdAt.split('T')[0], item.createdAt.split('T')[1].substring(0,5))}
                </CardDescription>
              </CardHeader>
              {item.status === 'failed' && item.errorMessage && (
                 <CardContent>
                    <p className="text-sm text-destructive bg-red-50 p-3 rounded-md"><strong>Hata:</strong> {item.errorMessage}</p>
                 </CardContent>
              )}
              {item.status === 'generated' && item.generatedStoryId && (
                 <CardContent>
                    <p className="text-sm text-green-700 bg-green-50 p-3 rounded-md">
                        Hikaye üretildi. <Button variant="link" asChild className="p-0 h-auto"><Link href={`/story/${item.generatedStoryId}`} target="_blank">Görüntüle</Link></Button> veya <Button variant="link" asChild className="p-0 h-auto"><Link href="/admin">Admin Panelinde Yönet</Link></Button>.
                    </p>
                 </CardContent>
              )}
              <CardFooter className="flex justify-end space-x-3">
                {item.status === 'pending' && (
                  <Button onClick={() => handleProcessGeneration(item.id)} disabled={isTransitioning} variant="default">
                    {isTransitioning ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <Wand2 className="mr-2 h-4 w-4" />}
                    Şimdi Üret
                  </Button>
                )}
                 {item.status === 'failed' && ( // Allow retry for failed items
                  <Button onClick={() => handleProcessGeneration(item.id)} disabled={isTransitioning} variant="outline">
                    {isTransitioning ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <RefreshCw className="mr-2 h-4 w-4" />}
                    Tekrar Dene
                  </Button>
                )}
                <AlertDialog>
                  <AlertDialogTrigger asChild>
                    <Button variant="destructive" disabled={isTransitioning}>
                      <Trash2 className="mr-2 h-4 w-4" /> Sil
                    </Button>
                  </AlertDialogTrigger>
                  <AlertDialogContent>
                    <AlertDialogHeader>
                      <AlertDialogTitle>Bu planı silmek istediğinize emin misiniz?</AlertDialogTitle>
                      <AlertDialogDescription>
                        {item.genre} türü için {formatDateDisplay(item.scheduledDate, item.scheduledTime)} tarihli üretim planı kalıcı olarak silinecektir. Bu işlem geri alınamaz.
                      </AlertDialogDescription>
                    </AlertDialogHeader>
                    <AlertDialogFooter>
                      <AlertDialogCancel disabled={isTransitioning}>İptal</AlertDialogCancel>
                      <AlertDialogAction
                        onClick={() => handleDeleteGeneration(item.id, item.genre, item.scheduledDate, item.scheduledTime)}
                        className="bg-destructive hover:bg-destructive/90"
                        disabled={isTransitioning}
                      >
                        {isTransitioning ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : null}
                        Evet, Planı Sil
                      </AlertDialogAction>
                    </AlertDialogFooter>
                  </AlertDialogContent>
                </AlertDialog>
              </CardFooter>
            </Card>
          ))}
        </div>
      )}
    </div>
  );
}


    