
// This is an autogenerated file from Firebase Studio.
'use client';

import { useEffect, useState, useTransition } from 'react';
import Link from 'next/link';
import type { ScheduledGeneration, StoryGenre, Story } from '@/lib/types';
import { 
    getScheduledGenerations, 
    addScheduledGeneration as dbAddScheduledGeneration,
    deleteScheduledGenerationById as dbDeleteScheduledGenerationById,
    updateScheduledGenerationStatus as dbUpdateScheduledGenerationStatus,
    addStory as dbAddStory 
} from '@/lib/mock-db'; 
import { GENRES } from '@/lib/constants';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Input } from '@/components/ui/input';
import { Calendar } from '@/components/ui/calendar';
import { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';
import { useToast } from '@/hooks/use-toast';
import { scheduleStoryGenerationAction, processScheduledGenerationAction, deleteScheduledGenerationAction } from '@/lib/actions';
import { Loader2, AlertTriangle, CalendarPlus, CalendarClock, Trash2, Wand2, CheckCircle, XCircle, Info, CalendarCheck2, RefreshCw } from 'lucide-react';
import { format, parseISO, isValid } from 'date-fns';
import { tr } from 'date-fns/locale';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog";
import { Label } from '@/components/ui/label';
import { Badge } from '@/components/ui/badge';
import { Separator } from '@/components/ui/separator';

export default function SchedulingPage() {
  const [scheduledGenerations, setScheduledGenerations] = useState<ScheduledGeneration[]>([]);
  const [isLoadingPage, setIsLoadingPage] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [isSavingOrDeleting, startSavingOrDeletingTransition] = useTransition();
  const { toast } = useToast();

  const [newScheduleDate, setNewScheduleDate] = useState<Date | undefined>(new Date());
  const [newScheduleTime, setNewScheduleTime] = useState<string>("10:00");
  const [newScheduleGenre, setNewScheduleGenre] = useState<StoryGenre | undefined>(undefined);
  
  const [autoProcessingAttemptedOnLoad, setAutoProcessingAttemptedOnLoad] = useState(false);
  const [processingItems, setProcessingItems] = useState<Set<string>>(new Set());

  const fetchScheduledItems = async (isManualRefresh = false, showLoadingSpinner = true) => {
    if (showLoadingSpinner && !isManualRefresh && !autoProcessingAttemptedOnLoad) {
      setIsLoadingPage(true);
    }
    setError(null);
    console.log("[Fetch] Starting fetchScheduledItems. ManualRefresh:", isManualRefresh, "AutoProcessAttempted:", autoProcessingAttemptedOnLoad);

    try {
      let items = await getScheduledGenerations(); 
      const now = new Date();
      
      const dueItems = items.filter(item => {
        if (item.status !== 'pending') return false;
        try {
          const scheduledDateTime = parseISO(`${item.scheduledDate}T${item.scheduledTime}`);
          return isValid(scheduledDateTime) && scheduledDateTime <= now;
        } catch (e) {
          console.error("[Fetch] Error parsing scheduled date/time for item:", item.id, e);
          return false; 
        }
      }).filter(item => !processingItems.has(item.id)); // Ensure not already processing

      console.log(`[Fetch] Found ${dueItems.length} due items to process automatically.`);

      if (dueItems.length > 0 && (isManualRefresh || !autoProcessingAttemptedOnLoad)) {
        const toastTitle = isManualRefresh ? "Manuel Üretim Kontrolü" : "Otomatik Üretim Kontrolü";
        
        // Mark all due items as processing *before* starting the loop
        setProcessingItems(prev => {
          const next = new Set(prev);
          dueItems.forEach(item => next.add(item.id));
          console.log("[Fetch] Updated processingItems for auto-process:", Array.from(next));
          return next;
        });

        toast({
            title: toastTitle,
            description: `${dueItems.length} adet zamanı gelmiş planlı üretim şimdi işleniyor... Lütfen bekleyin.`,
        });

        const processingPromises = dueItems.map(async (item) => {
          console.log(`[Fetch][AutoProcess] Starting for item ID: ${item.id}, Genre: ${item.genre}`);
          try {
            // Pass item.genre to the action
            const result = await processScheduledGenerationAction(item.id, item.genre); 
            console.log(`[Fetch][AutoProcess] Result for ${item.id}:`, result);

            if (result.success && result.storyData && result.scheduledGenerationId) {
              const newStory = await dbAddStory(result.storyData); 
              await dbUpdateScheduledGenerationStatus(result.scheduledGenerationId, 'generated', newStory.id);
              toast({
                variant: "default",
                title: "Otomatik Hikaye Üretildi!",
                description: `"${newStory.title}" (${item.genre}) başarıyla oluşturuldu ve kuyruğa eklendi.`,
                action: <CheckCircle className="text-green-500" />,
              });
            } else { 
              await dbUpdateScheduledGenerationStatus(result.scheduledGenerationId, 'failed', undefined, result.error || 'Bilinmeyen bir hata oluştu.');
              toast({
                variant: "destructive",
                title: "Otomatik Üretim Başarısız",
                description: `${item.genre} türündeki zamanlanmış hikaye üretilemedi: ${result.error || 'Bilinmeyen bir hata oluştu.'}`,
              });
            }
          } catch (e) {
             console.error(`[Fetch][AutoProcess] Error processing item ${item.id}:`, e);
             await dbUpdateScheduledGenerationStatus(item.id, 'failed', undefined, e instanceof Error ? e.message : String(e));
             toast({
                variant: "destructive",
                title: "Otomatik Üretim Hatası",
                description: `${item.genre} türündeki zamanlanmış hikaye işlenirken bir hata oluştu: ${e instanceof Error ? e.message : String(e)}`,
              });
          } finally {
            setProcessingItems(prev => {
              const next = new Set(prev);
              next.delete(item.id);
              console.log(`[Fetch][AutoProcess] Removed ${item.id} from processingItems. Current:`, Array.from(next));
              return next;
            });
          }
        });
        
        await Promise.allSettled(processingPromises);
        console.log("[Fetch] All auto-processing promises settled.");
        
        if (!autoProcessingAttemptedOnLoad && !isManualRefresh) {
            setAutoProcessingAttemptedOnLoad(true);
            console.log("[Fetch] autoProcessingAttemptedOnLoad set to true.");
        }
        // Re-fetch after all processing attempts to get final statuses
        items = await getScheduledGenerations(); 
      }
      
      setScheduledGenerations(items);
      console.log("[Fetch] Final scheduledGenerations state set:", items.length, "items");
    } catch (e) {
      setError(e instanceof Error ? e.message : 'Planlanmış üretimler yüklenemedi.');
      console.error("[Fetch] Overall error in fetchScheduledItems:", e);
    } finally {
      if (showLoadingSpinner && !isManualRefresh && !autoProcessingAttemptedOnLoad && isLoadingPage) {
        setIsLoadingPage(false);
        console.log("[Fetch] setIsLoadingPage to false (initial load).");
      }
       // Safety clear if page was loading and error occurred.
      if (isLoadingPage && error && showLoadingSpinner) setProcessingItems(new Set());
    }
  };
  
  useEffect(() => {
    fetchScheduledItems(false, true); // Initial load, show spinner
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []); 

  const handleAddScheduledGeneration = () => {
    if (!newScheduleDate || !newScheduleTime || !newScheduleGenre) {
      toast({ variant: 'destructive', title: 'Eksik Bilgi', description: 'Lütfen tarih, saat ve tür seçin.' });
      return;
    }
    const dateString = format(newScheduleDate, 'yyyy-MM-dd');
    startSavingOrDeletingTransition(async () => {
      const actionResult = await scheduleStoryGenerationAction(dateString, newScheduleTime, newScheduleGenre as StoryGenre);
      
      if (actionResult.success && actionResult.newScheduledGenerationData) {
        // Client-side localStorage update
        const { newScheduledGeneration, allItems } = await dbAddScheduledGeneration(actionResult.newScheduledGenerationData);
        
        toast({ 
          title: 'Hikaye Üretimi Planlandı', 
          description: `${newScheduledGeneration.genre} türünde hikaye ${formatDateDisplay(newScheduledGeneration.scheduledDate, newScheduledGeneration.scheduledTime)} için planlandı.` 
        });
        setScheduledGenerations(allItems); // Use the complete, sorted list from dbAddScheduledGeneration
        
        setNewScheduleDate(new Date());
        setNewScheduleTime("10:00");
        setNewScheduleGenre(undefined);
      } else {
        toast({ variant: 'destructive', title: 'Planlama Başarısız', description: actionResult.error });
      }
    });
  };

  const handleProcessGeneration = (id: string, genre: StoryGenre) => {
    if (processingItems.has(id)) {
        console.log(`[ManualProcess] Item ${id} is already being processed.`);
        return;
    }

    console.log(`[ManualProcess] Starting for item ID: ${id}, Genre: ${genre}`);
    setProcessingItems(prev => new Set(prev).add(id)); // Mark as processing for UI update
    toast({
      title: "Manuel Üretim Başlatıldı",
      description: `"${genre}" türündeki hikaye şimdi üretiliyor... Lütfen bekleyin.`
    });

    startSavingOrDeletingTransition(async () => { 
      try {
        // Pass genre to the action
        const result = await processScheduledGenerationAction(id, genre);
        console.log(`[ManualProcess] Result for ${id}:`, result);

        if (result.success && result.storyData && result.scheduledGenerationId) {
          // Client-side localStorage updates
          const newStory = await dbAddStory(result.storyData);
          await dbUpdateScheduledGenerationStatus(result.scheduledGenerationId, 'generated', newStory.id);
          toast({ title: 'Hikaye Üretildi!', description: `"${newStory.title}" (${genre}) başarıyla oluşturuldu ve admin panelindeki kuyruğa eklendi.` });
        } else if (result.scheduledGenerationId) { 
          // Client-side localStorage update for failure
          await dbUpdateScheduledGenerationStatus(result.scheduledGenerationId, 'failed', undefined, result.error || "Üretim Başarısız oldu, hikaye detayı alınamadı.");
          toast({ variant: 'destructive', title: 'Üretim Başarısız', description: `${genre} üretilemedi: ${result.error || "Hikaye detayı alınamadı."}` });
        } else { 
           // This case should ideally not happen if scheduledGenerationId is always returned
           console.error(`[ManualProcess] Unknown error for ${id}, result did not contain scheduledGenerationId.`);
           toast({ variant: 'destructive', title: 'Üretim Hatası', description: `${genre} üretilemedi: ${result.error || "Bilinmeyen bir hata oluştu."}` });
           // Attempt to mark as failed if ID is known, even if action result was malformed
           await dbUpdateScheduledGenerationStatus(id, 'failed', undefined, result.error || "Bilinmeyen bir hata oluştu.");
        }
      } catch (e) {
        console.error(`[ManualProcess] Catch block error for ID: ${id}:`, e);
        toast({ variant: 'destructive', title: 'İşlem Sırasında Hata', description: e instanceof Error ? e.message : "Bilinmeyen bir hata." });
        try {
          // Attempt to mark as failed in localStorage
          await dbUpdateScheduledGenerationStatus(id, 'failed', undefined, e instanceof Error ? e.message : "Beklenmedik hata sonucu işlem başarısız.");
        } catch (dbErr) { console.error("[ManualProcess] DB durum güncelleme hatası (catch):", dbErr); }
      } finally {
        console.log(`[ManualProcess] Finalizing for item ID: ${id}`);
        setProcessingItems(prev => { // Unmark as processing
          const next = new Set(prev);
          next.delete(id);
          console.log(`[ManualProcess] Removed ${id} from processingItems. Current:`, Array.from(next));
          return next;
        });
        // Refresh the list from localStorage after processing
        await fetchScheduledItems(true, false); 
      }
    });
  };

  const handleDeleteGeneration = (id: string, genre: StoryGenre, date: string, time: string) => {
    startSavingOrDeletingTransition(async () => {
      // Optimistically update UI, though fetchScheduledItems will be the source of truth
      setScheduledGenerations(prev => prev.filter(item => item.id !== id));
      
      const actionResult = await deleteScheduledGenerationAction(id);
      if (actionResult.success && actionResult.scheduledGenerationIdToDelete) {
        // Client-side localStorage deletion
        await dbDeleteScheduledGenerationById(actionResult.scheduledGenerationIdToDelete);
        toast({ title: 'Plan Silindi', description: `${genre} türündeki ${formatDateDisplay(date, time)} tarihli plan silindi.` });
        // Re-fetch to ensure consistency, though optimistic update is done
        await fetchScheduledItems(true, false); 
      } else {
        toast({ variant: 'destructive', title: 'Silme Başarısız', description: actionResult.error });
        await fetchScheduledItems(true, false); // Re-fetch on failure to revert optimistic update if needed
      }
    });
  };

  const formatDateDisplay = (dateString?: string, timeString?: string) => {
    if (!dateString) return 'N/A';
    try {
      const datePart = parseISO(dateString); 
      if (!isValid(datePart)) return 'Geçersiz Tarih';
      
      let hours = 0;
      let minutes = 0;

      if (timeString) { 
        const timeParts = timeString.split(':');
        if (timeParts.length === 2) {
          const parsedHours = parseInt(timeParts[0], 10);
          const parsedMinutes = parseInt(timeParts[1], 10);
          if (!isNaN(parsedHours) && parsedHours >= 0 && parsedHours <= 23) {
            hours = parsedHours;
          }
          if (!isNaN(parsedMinutes) && parsedMinutes >= 0 && parsedMinutes <= 59) {
            minutes = parsedMinutes;
          }
        }
      }
      const dateTimeToFormat = new Date(datePart.getFullYear(), datePart.getMonth(), datePart.getDate(), hours, minutes);
      return format(dateTimeToFormat, 'dd MMMM yyyy, HH:mm', { locale: tr });

    } catch (e) {
      console.error("Error formatting date display:", dateString, timeString, e);
      return `${dateString} ${timeString || ''} (Hatalı Format)`.trim();
    }
  };
  
  const formatCreatedAtDisplay = (isoDateString?: string) => {
    if (!isoDateString) return 'N/A';
    try {
      const date = parseISO(isoDateString);
      if(!isValid(date)) return 'Geçersiz Oluşturulma Tarihi';
      return format(date, 'dd MMMM yyyy, HH:mm', { locale: tr });
    } catch (e) {
      return 'Hatalı Oluşturulma Tarihi';
    }
  };

  const getStatusBadge = (status: ScheduledGeneration['status'], itemId: string) => {
    if (processingItems.has(itemId)) {
      return <Badge variant="outline" className="bg-blue-100 text-blue-700 border-blue-300"><Loader2 className="mr-1 h-3 w-3 animate-spin" />İşleniyor...</Badge>;
    }
    switch (status) {
      case 'pending':
        return <Badge variant="outline" className="bg-yellow-100 text-yellow-700 border-yellow-300"><CalendarClock className="mr-1 h-3 w-3" />Beklemede</Badge>;
      case 'generated':
        return <Badge variant="outline" className="bg-green-100 text-green-700 border-green-300"><CheckCircle className="mr-1 h-3 w-3" />Üretildi</Badge>;
      case 'failed':
        return <Badge variant="destructive"><XCircle className="mr-1 h-3 w-3" />Başarısız</Badge>;
      default:
        return <Badge variant="secondary">Bilinmiyor</Badge>;
    }
  };
  
  const isRefreshDisabled = isSavingOrDeleting || (isLoadingPage && !autoProcessingAttemptedOnLoad) || processingItems.size > 0;

  if (isLoadingPage && !autoProcessingAttemptedOnLoad && scheduledGenerations.length === 0) { 
    return (
      <div className="flex justify-center items-center min-h-[calc(100vh-200px)]">
        <Loader2 className="h-12 w-12 animate-spin text-primary" />
        <p className="ml-4 text-lg text-muted-foreground">Planlar yükleniyor ve otomatik üretimler kontrol ediliyor...</p>
      </div>
    );
  }

  if (error) {
    return (
      <div className="text-center py-10 text-red-600 bg-red-50 p-6 rounded-lg shadow-md">
        <AlertTriangle className="mx-auto h-12 w-12 mb-4" />
        <h2 className="text-2xl font-semibold mb-2">Planlar Yüklenirken Hata Oluştu</h2>
        <p>{error}</p>
        <Button onClick={() => fetchScheduledItems(true, true)} variant="destructive" className="mt-4">
          <RefreshCw className="mr-2 h-4 w-4" /> Tekrar Dene
        </Button>
      </div>
    );
  }

  return (
    <div className="space-y-8">
      <div className="flex flex-col sm:flex-row justify-between items-center gap-4">
        <h1 className="text-3xl md:text-4xl font-bold text-foreground tracking-tight">Hikaye Üretim Planlayıcısı</h1>
         <Button variant="outline" asChild>
          <Link href="/admin">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="mr-2 h-4 w-4"><path d="m12 19-7-7 7-7"/><path d="M19 12H5"/></svg>
            Admin Paneline Dön
          </Link>
        </Button>
      </div>
      
      <div className="bg-blue-50 border-l-4 border-blue-500 text-blue-700 p-4 rounded-md shadow" role="alert">
        <div className="flex items-center">
          <Info className="h-6 w-6 mr-3" />
          <div>
            <p className="font-bold">Otomatik Üretim Bilgisi</p>
            <p className="text-sm">Bu sayfa yüklendiğinde veya "Yenile" butonuna tıklandığında, zamanı gelmiş "beklemede" olan planlar otomatik olarak işlenmeye çalışılır. Üretilen hikayeler admin panelindeki "Hikaye Kuyruğu" bölümüne "Beklemede" olarak eklenir. Veriler tarayıcınızın yerel depolamasında saklandığı için, bu işlemler yalnızca bu sayfa açıkken ve tarayıcınız çalışırken gerçekleşir.</p>
          </div>
        </div>
      </div>

      <Card className="shadow-lg">
        <CardHeader>
          <CardTitle className="text-2xl flex items-center">
            <CalendarPlus className="mr-3 h-7 w-7 text-primary" />
            Yeni Hikaye Üretimi Planla
          </CardTitle>
          <CardDescription>Belirli bir tarih, saat ve tür için otomatik hikaye üretimi planlayın.</CardDescription>
        </CardHeader>
        <CardContent className="space-y-6">
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4 items-end">
            <div>
              <Label htmlFor="new-schedule-date" className="block mb-1 font-medium">Tarih</Label>
              <Popover>
                <PopoverTrigger asChild>
                  <Button
                    id="new-schedule-date"
                    variant={"outline"}
                    className={`w-full justify-start text-left font-normal ${!newScheduleDate && "text-muted-foreground"}`}
                  >
                    <CalendarClock className="mr-2 h-4 w-4" />
                    {newScheduleDate ? format(newScheduleDate, "PPP", { locale: tr }) : <span>Bir tarih seçin</span>}
                  </Button>
                </PopoverTrigger>
                <PopoverContent className="w-auto p-0">
                  <Calendar
                    mode="single"
                    selected={newScheduleDate}
                    onSelect={setNewScheduleDate}
                    initialFocus
                    locale={tr}
                    disabled={(date) => date < new Date(new Date().setHours(0,0,0,0))} 
                  />
                </PopoverContent>
              </Popover>
            </div>
            <div>
              <Label htmlFor="new-schedule-time" className="block mb-1 font-medium">Saat</Label>
              <Input
                id="new-schedule-time"
                type="time"
                value={newScheduleTime}
                onChange={(e) => setNewScheduleTime(e.target.value)}
                className="w-full"
              />
            </div>
            <div>
              <Label htmlFor="new-schedule-genre" className="block mb-1 font-medium">Tür</Label>
              <Select value={newScheduleGenre} onValueChange={(value) => setNewScheduleGenre(value as StoryGenre)}>
                <SelectTrigger id="new-schedule-genre" className="w-full">
                  <SelectValue placeholder="Bir tür seçin..." />
                </SelectTrigger>
                <SelectContent>
                  {GENRES.map(g => <SelectItem key={g} value={g}>{g}</SelectItem>)}
                </SelectContent>
              </Select>
            </div>
          </div>
          <Button onClick={handleAddScheduledGeneration} disabled={isSavingOrDeleting || !newScheduleDate || !newScheduleTime || !newScheduleGenre} className="w-full md:w-auto">
            {isSavingOrDeleting ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <CalendarCheck2 className="mr-2 h-4 w-4" />}
            Üretimi Planla
          </Button>
        </CardContent>
      </Card>

      <Separator className="my-8" />

       <div className="flex items-center mb-6">
        <h2 className="text-2xl md:text-3xl font-semibold text-foreground tracking-tight">
          Planlanmış Üretimler ({scheduledGenerations.length})
        </h2>
        <Button onClick={() => fetchScheduledItems(true, false)} variant="ghost" size="icon" className="ml-2" disabled={isRefreshDisabled}>
            <RefreshCw className={`h-5 w-5 ${(isRefreshDisabled && !isLoadingPage && processingItems.size > 0) || (isSavingOrDeleting && processingItems.size > 0) ? 'animate-spin' : ''}`} />
        </Button>
      </div>

      {(isLoadingPage && !autoProcessingAttemptedOnLoad && scheduledGenerations.length === 0) ? (
         <div className="flex justify-center items-center min-h-[200px]">
            <Loader2 className="h-8 w-8 animate-spin text-primary" />
            <p className="ml-3 text-muted-foreground">Planlar yükleniyor...</p>
        </div>
      ) : scheduledGenerations.length === 0 ? (
        <div className="text-center py-10 text-muted-foreground bg-card p-6 rounded-lg shadow">
          <Info className="mx-auto h-12 w-12 mb-4" />
          <p className="text-lg">Henüz planlanmış bir hikaye üretimi yok.</p>
          <p>Yukarıdaki formu kullanarak yeni üretimler planlayabilirsiniz.</p>
        </div>
      ) : (
        <div className="space-y-4">
          {scheduledGenerations.map(item => {
            const isCurrentlyProcessing = processingItems.has(item.id);
            return (
            <Card key={item.id} className="shadow-md hover:shadow-lg transition-shadow">
              <CardHeader>
                <CardTitle className="flex justify-between items-center">
                  <span>{item.genre} Türünde Hikaye</span>
                  {getStatusBadge(item.status, item.id)}
                </CardTitle>
                <CardDescription>
                  Planlanan Zaman: {formatDateDisplay(item.scheduledDate, item.scheduledTime)}
                  <br/>
                  Oluşturulma Tarihi: {formatCreatedAtDisplay(item.createdAt)}
                </CardDescription>
              </CardHeader>
              {item.status === 'failed' && item.errorMessage && (
                 <CardContent>
                    <p className="text-sm text-destructive bg-red-50 p-3 rounded-md"><strong>Hata:</strong> {item.errorMessage}</p>
                 </CardContent>
              )}
              {item.status === 'generated' && item.generatedStoryId && (
                 <CardContent>
                    <p className="text-sm text-green-700 bg-green-50 p-3 rounded-md">
                        Hikaye üretildi. İlgili hikayeyi Admin panelindeki "Hikaye Kuyruğu" bölümünde (Beklemede olarak) bulabilirsiniz.
                    </p>
                 </CardContent>
              )}
              <CardFooter className="flex flex-wrap justify-end gap-2">
                {(item.status === 'pending' || item.status === 'failed') && (
                  <Button 
                    onClick={() => handleProcessGeneration(item.id, item.genre)} 
                    disabled={isSavingOrDeleting || isCurrentlyProcessing}
                    variant={item.status === 'failed' ? "outline" : "default"}
                  >
                    {isCurrentlyProcessing ? (
                        <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                    ) : item.status === 'failed' ? (
                        <RefreshCw className="mr-2 h-4 w-4" />
                    ) : (
                        <Wand2 className="mr-2 h-4 w-4" />
                    )}
                    {item.status === 'failed' ? 'Tekrar Dene' : 'Şimdi Üret'}
                  </Button>
                )}
                <AlertDialog>
                  <AlertDialogTrigger asChild>
                    <Button variant="destructive" disabled={isSavingOrDeleting || isCurrentlyProcessing}>
                      <Trash2 className="mr-2 h-4 w-4" /> Sil
                    </Button>
                  </AlertDialogTrigger>
                  <AlertDialogContent>
                    <AlertDialogHeader>
                      <AlertDialogTitle>Bu planı silmek istediğinize emin misiniz?</AlertDialogTitle>
                      <AlertDialogDescription>
                        {item.genre} türü için {formatDateDisplay(item.scheduledDate, item.scheduledTime)} tarihli üretim planı kalıcı olarak silinecektir. Bu işlem geri alınamaz.
                      </AlertDialogDescription>
                    </AlertDialogHeader>
                    <AlertDialogFooter>
                      <AlertDialogCancel disabled={isSavingOrDeleting || isCurrentlyProcessing}>İptal</AlertDialogCancel>
                      <AlertDialogAction
                        onClick={() => handleDeleteGeneration(item.id, item.genre, item.scheduledDate, item.scheduledTime)}
                        className="bg-destructive hover:bg-destructive/90"
                        disabled={isSavingOrDeleting || isCurrentlyProcessing}
                      >
                        {(isSavingOrDeleting && isCurrentlyProcessing /* Show spinner only if this delete is part of a general transition AND this item is processing */ ) ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : null}
                        Evet, Planı Sil
                      </AlertDialogAction>
                    </AlertDialogFooter>
                  </AlertDialogContent>
                </AlertDialog>
              </CardFooter>
            </Card>
          )})}
        </div>
      )}
    </div>
  );
}
    

    
