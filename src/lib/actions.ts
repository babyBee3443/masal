
// This is an autogenerated file from Firebase Studio.
'use server';

import type { Story, StoryGenre, ScheduledGeneration, WeeklyScheduleItem, DayOfWeek } from '@/lib/types';
import type { StoryLength, StoryComplexity } from '@/lib/constants';


import { generateStory as aiGenerateStory } from '@/ai/flows/generate-story';
import { regenerateAIImage as aiRegenerateAIImage } from '@/ai/flows/generate-image';

// Client components will call mock-db functions directly for localStorage modifications.
// Server actions are now primarily for:
// 1. AI interactions (which must run server-side).
// 2. Data validation/preparation before client handles localStorage.
// 3. Reading data if a server component needs it (though prefer client for localStorage consistency).

export async function publishStoryAction(storyId: string) {
  console.warn("publishStoryAction (server): Client should handle localStorage update. This action now only returns data for the client to act upon.");
  // Client will call: `await dbUpdateStory(storyId, { status: 'published', publishedAt: new Date().toISOString(), scheduledAtDate: undefined, scheduledAtTime: undefined });`
  return { 
      success: true, 
      storyDataToUpdate: { // Data for the client to use for updating localStorage
          id: storyId, 
          status: 'published' as 'published', 
          publishedAt: new Date().toISOString(),
          scheduledAtDate: undefined, 
          scheduledAtTime: undefined 
      } 
  };
}

export async function deleteStoryAction(storyId: string) {
  console.warn("deleteStoryAction (server): Client should handle localStorage deletion. This action only returns an ID for the client.");
  // Client will call: `await dbDeleteStoryById(storyId);`
  return { success: true, storyIdToDelete: storyId }; 
}

export async function updateStoryCategoryAction(storyId: string, newGenre: StoryGenre) {
  console.warn("updateStoryCategoryAction (server): Client should handle localStorage update. This action returns data for client update.");
  // Client will call: `await dbUpdateStory(storyId, { genre: newGenre });`
  return { success: true, storyDataToUpdate: { id: storyId, genre: newGenre } };
}

export async function approveStoryAction(storyId: string): Promise<{ success: boolean; storyDataToUpdate?: Partial<Story> & {id: string}; error?: string}> {
    console.warn("approveStoryAction (server): Client handles localStorage update. This returns data for client update.");
    // Client will call: `await dbUpdateStory(storyId, { status: 'pending' });`
    return {
        success: true,
        storyDataToUpdate: {
            id: storyId,
            status: 'pending'
        }
    };
}


export async function generateNewStoryAction(
  genre: StoryGenre, 
  length?: StoryLength, 
  complexity?: StoryComplexity
): Promise<{ success: boolean; storyData?: Omit<Story, 'id' | 'summary' | 'createdAt'>; error?: string }> {
  try {
    console.log(`[Action] generateNewStoryAction: Generating story for genre: ${genre}, length: ${length}, complexity: ${complexity}`);
    const aiResult = await aiGenerateStory({ genre, length, complexity });
    console.log(`[Action] generateNewStoryAction: AI result received: Title: ${aiResult?.title ? 'Yes' : 'No'}, Content: ${aiResult?.content ? 'Yes' : 'No'}, ImageUrl: ${aiResult?.imageUrl ? 'Yes' : 'No'}`);

    if (!aiResult || !aiResult.title || !aiResult.content || !aiResult.imageUrl) {
      console.error("[Action] generateNewStoryAction: AI did not return expected title, content, or imageUrl.", aiResult);
      let specificError = 'Yapay zeka hikaye başlığı, içeriği veya görseli oluşturamadı.';
      if (!aiResult?.title) specificError += ' Başlık eksik.';
      if (!aiResult?.content) specificError += ' İçerik eksik.';
      if (!aiResult?.imageUrl) specificError += ' Görsel URL eksik.';
      throw new Error(specificError);
    }
    
    // TODO: getdusbox@gmail.com adresine onay e-postası gönderilecek (hikaye içeriği ve onay bağlantısı ile).
    // E-posta gönderim kodu burada olmalı, bir e-posta servisi (örn: Nodemailer, SendGrid) kullanarak.
    // Örnek: await sendApprovalEmail('getdusbox@gmail.com', aiResult.title, aiResult.content);

    const newStoryData: Omit<Story, 'id' | 'summary' | 'createdAt'> = {
      title: aiResult.title,
      content: aiResult.content,
      imageUrl: aiResult.imageUrl, 
      genre: genre,
      status: 'awaiting_approval', // New stories now await approval
    };
    console.log(`[Action] generateNewStoryAction: Story data prepared successfully for genre: ${genre}, status: 'awaiting_approval'`);
    return { success: true, storyData: newStoryData };
  } catch (error) {
    console.error(`[Action] generateNewStoryAction: Error generating new story for genre ${genre}:`, error);
    let errorMessage = 'Yapay zeka ile hikaye oluşturulamadı.';
    if (error instanceof Error) {
        errorMessage = error.message;
    } else if (typeof error === 'string') {
        errorMessage = error;
    }
    // @ts-ignore
    if (error?.details?.code === 'ABORTED' && error?.details?.message?.includes('SafetyPolicyViolation')) {
      errorMessage = 'Hikaye üretimi güvenlik politikalarını ihlal ettiği için engellendi. Lütfen farklı bir tür veya konu deneyin.';
    }
    // @ts-ignore
    else if (error?.cause?.code === 'blocked' && error?.cause?.message?.includes('SAFETY')) {
        errorMessage = 'Hikaye üretimi güvenlik filtreleri tarafından engellendi. İçerik uygunsuz olabilir.';
    }
    
    return { success: false, error: errorMessage };
  }
}

export async function regenerateStoryImageAction(storyId: string, storyText: string): Promise<{ success: boolean; imageUrl?: string; storyIdToUpdate?: string; error?: string }> {
  try {
    const aiResult = await aiRegenerateAIImage({ storyText });
    if (!aiResult.imageUrl) {
      throw new Error('Yapay zeka yeni bir görsel URLsi oluşturamadı.');
    }
    // Client will call: `await dbUpdateStory(storyId, { imageUrl: aiResult.imageUrl });`
    return { success: true, imageUrl: aiResult.imageUrl, storyIdToUpdate: storyId };
  } catch (error) {
    console.error("[Action] regenerateStoryImageAction: Error regenerating image:", error);
    return { success: false, error: error instanceof Error ? error.message : 'Görsel yeniden oluşturulamadı' };
  }
}

export async function scheduleStoryPublicationAction(storyId: string, date: string, time: string): Promise<{ success: boolean; storyDataToUpdate?: Partial<Story> & { id: string }; error?: string }> {
  console.warn("scheduleStoryPublicationAction (server): Client handles localStorage update. This action returns data for client update.");
  // Client will call: `await dbUpdateStory(storyId, { scheduledAtDate: date, scheduledAtTime: time, status: 'pending' });`
  return { 
    success: true, 
    storyDataToUpdate: { 
      id: storyId, 
      scheduledAtDate: date, 
      scheduledAtTime: time, 
      status: 'pending' // Ensure status is pending if it's being scheduled
    } 
  };
}

// For Scheduled Story Generation (Date-based planner)
export async function scheduleStoryGenerationAction(
  scheduledDate: string, 
  scheduledTime: string, 
  genre: StoryGenre
): Promise<{ 
  success: boolean; 
  newScheduledGenerationData?: Omit<ScheduledGeneration, 'id' | 'status' | 'createdAt'>; // Data for client to add to localStorage
  error?: string 
}> {
  console.log(`[Action] scheduleStoryGenerationAction: Received date: ${scheduledDate}, time: ${scheduledTime}, genre: ${genre}`);
  try {
    if (!scheduledDate || !scheduledTime || !genre) {
      console.error("[Action] scheduleStoryGenerationAction: Missing date, time, or genre.");
      return { success: false, error: "Lütfen tarih, saat ve tür bilgilerini eksiksiz girin." };
    }
    // This action now only prepares the data. Client will use dbAddScheduledGeneration.
    const newScheduledGenerationData: Omit<ScheduledGeneration, 'id' | 'status' | 'createdAt'> = {
      scheduledDate,
      scheduledTime,
      genre
    };
    console.log("[Action] scheduleStoryGenerationAction: Prepared data for client:", newScheduledGenerationData);
    return { success: true, newScheduledGenerationData };
  } catch (e) {
    const error = e instanceof Error ? e.message : "Planlama sırasında bir hata oluştu (sunucu).";
    console.error("[Action] scheduleStoryGenerationAction: Error:", error);
    return { success: false, error };
  }
}

export async function processScheduledGenerationAction(id: string, genre: StoryGenre): Promise<{ 
  success: boolean; 
  storyData?: Omit<Story, 'id' | 'summary' | 'createdAt'>; // Data for the new story (status will be 'awaiting_approval')
  error?: string; 
  scheduledGenerationId: string; // ID of the scheduled item to update its status
}> {
  console.log(`[Action] processScheduledGenerationAction: Processing ID: ${id} for Genre: ${genre}`);
  
  try {
    const generationResult = await generateNewStoryAction(genre, undefined, undefined); // Uses default length/complexity

    if (generationResult.success && generationResult.storyData) {
      console.log(`[Action] processScheduledGenerationAction: Story generated successfully for ID: ${id}, Genre: ${genre}. Status: ${generationResult.storyData.status}`);
      // TODO: getdusbox@gmail.com adresine onay e-postası gönderilecek (hikaye içeriği ve onay bağlantısı ile).
      // Örnek: await sendApprovalEmail('getdusbox@gmail.com', generationResult.storyData.title, generationResult.storyData.content);
      return { 
        success: true, 
        storyData: generationResult.storyData, // This will have status: 'awaiting_approval'
        scheduledGenerationId: id,
      };
    } else {
      console.error(`[Action] processScheduledGenerationAction: Story generation failed for ID: ${id}. Error: ${generationResult.error}`);
      return { 
        success: false, 
        error: generationResult.error || "Hikaye üretilemedi (alt eylem başarısız).", 
        scheduledGenerationId: id,
      };
    }
  } catch (e) {
    const errorMsg = e instanceof Error ? e.message : "Planlanmış üretim işlenirken beklenmedik bir sunucu hatası oluştu.";
    console.error(`[Action] processScheduledGenerationAction: Catch block error for ID: ${id}:`, e);
    return { 
      success: false, 
      error: errorMsg, 
      scheduledGenerationId: id,
    };
  }
}

export async function deleteScheduledGenerationAction(id: string): Promise<{ success: boolean; error?: string; scheduledGenerationIdToDelete?: string }> {
  console.warn("deleteScheduledGenerationAction (server): Client handles localStorage deletion. This action returns ID for client.");
  // Client will call: `await dbDeleteScheduledGenerationById(id);`
  return { success: true, scheduledGenerationIdToDelete: id };
}


// For Weekly Schedule
export async function getWeeklySchedulesAction(): Promise<{ success: boolean; schedules?: WeeklyScheduleItem[]; error?: string; }> {
  console.warn("getWeeklySchedulesAction (server): Client reads from localStorage. This action is a placeholder if server-side data fetching was needed.");
  // Client will directly call `await dbGetWeeklySchedules();`
  return { success: true, schedules: [] }; 
}

export async function saveWeeklyScheduleSlotAction(
  dayOfWeek: DayOfWeek, 
  time: string, 
  genre: StoryGenre | null // Allow null to clear a slot
): Promise<{ 
  success: boolean; 
  slotToSave?: { dayOfWeek: DayOfWeek; time: string; genre: StoryGenre | null }; // Data for client to upsert/delete in localStorage
  error?: string; 
}> {
  console.log(`[Action] saveWeeklyScheduleSlotAction: Received day: ${dayOfWeek}, time: ${time}, genre: ${genre}`);
  try {
    // Basic validation for genre if it's not null
    if (genre && !["Korku", "Macera", "Romantik", "Bilim Kurgu", "Fabl", "Felsefi"].includes(genre)) {
        console.error("[Action] saveWeeklyScheduleSlotAction: Invalid genre provided:", genre);
        return { success: false, error: "Geçersiz tür." };
    }
    // This action prepares data. Client will use dbUpsertWeeklySchedule or dbDeleteWeeklyScheduleByDayTime.
    const slotToSave = { dayOfWeek, time, genre };
    console.log("[Action] saveWeeklyScheduleSlotAction: Prepared data for client:", slotToSave);
    return { success: true, slotToSave };
  } catch (e) {
    const error = e instanceof Error ? e.message : "Haftalık plan kaydedilirken bir sunucu hatası oluştu.";
    console.error("[Action] saveWeeklyScheduleSlotAction: Error:", error);
    return { success: false, error };
  }
}
