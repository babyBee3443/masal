
// This is an autogenerated file from Firebase Studio.
'use server';

import { revalidatePath } from 'next/cache';
import type { Story, StoryGenre, ScheduledGeneration, WeeklyScheduleItem, DayOfWeek } from '@/lib/types';
import { 
  addStory as dbAddStory, 
  deleteStoryById as dbDeleteStoryById, 
  updateStory as dbUpdateStory, 
  getStoryById as dbGetStoryById,
  getStories as dbGetStories,
  addScheduledGeneration as dbAddScheduledGeneration,
  deleteScheduledGenerationById as dbDeleteScheduledGenerationById,
  updateScheduledGenerationStatus as dbUpdateScheduledGenerationStatus,
  getScheduledGenerationById as dbGetScheduledGenerationById,
  getScheduledGenerations as dbGetScheduledGenerations, 
  getWeeklySchedules as dbGetWeeklySchedules,
  upsertWeeklySchedule as dbUpsertWeeklySchedule,
  deleteWeeklyScheduleByDayTime as dbDeleteWeeklyScheduleByDayTime
} from '@/lib/mock-db';
import { generateStory as aiGenerateStory } from '@/ai/flows/generate-story';
import { regenerateAIImage as aiRegenerateAIImage } from '@/ai/flows/generate-image';

export async function publishStoryAction(storyId: string) {
  try {
    const updatedStory = await dbUpdateStory(storyId, { 
      status: 'published', 
      publishedAt: new Date().toISOString(),
      scheduledAtDate: undefined, 
      scheduledAtTime: undefined, 
    });
    if (!updatedStory) throw new Error('Hikaye bulunamadı');
    return { success: true, story: updatedStory };
  } catch (error) {
    console.error("Hikaye yayınlanamadı:", error);
    return { success: false, error: error instanceof Error ? error.message : 'Hikaye yayınlanamadı' };
  }
}

export async function deleteStoryAction(storyId: string) {
  try {
    const deleted = await dbDeleteStoryById(storyId);
    if (!deleted) throw new Error('Hikaye bulunamadı veya zaten silinmiş');
    return { success: true };
  } catch (error) {
    console.error("Hikaye silinemedi:", error);
    return { success: false, error: error instanceof Error ? error.message : 'Hikaye silinemedi' };
  }
}

export async function updateStoryCategoryAction(storyId: string, newGenre: StoryGenre) {
  try {
    const updatedStory = await dbUpdateStory(storyId, { genre: newGenre });
    if (!updatedStory) throw new Error('Hikaye kategorisi güncellenemedi');
    return { success: true, story: updatedStory };
  } catch (error) {
    console.error("Hikaye kategorisi güncellenemedi:", error);
    return { success: false, error: error instanceof Error ? error.message : 'Kategori güncellenemedi' };
  }
}

export async function generateNewStoryAction(genre: StoryGenre): Promise<{ success: boolean; story?: Story; error?: string }> {
  try {
    const aiResult = await aiGenerateStory({ genre });
    const newStoryData: Omit<Story, 'id' | 'summary' | 'createdAt'> = {
      title: aiResult.title,
      content: aiResult.content,
      imageUrl: aiResult.imageUrl || 'https://placehold.co/600x480.png', 
      genre: genre,
      status: 'pending',
    };
    const savedStory = await dbAddStory(newStoryData);
    return { success: true, story: savedStory };
  } catch (error)
 {
    console.error("Yeni hikaye oluşturulamadı (AI veya DB):", error);
    let errorMessage = 'Yapay zeka ile hikaye oluşturulamadı veya kaydedilemedi.';
    if (error instanceof Error) {
        errorMessage = error.message;
    } else if (typeof error === 'string') {
        errorMessage = error;
    }
    // @ts-ignore
    if (error?.details?.code === 'ABORTED' && error?.details?.message?.includes('SafetyPolicyViolation')) {
      errorMessage = 'Hikaye üretimi güvenlik politikalarını ihlal ettiği için engellendi. Lütfen farklı bir tür veya konu deneyin.';
    }
    
    return { success: false, error: errorMessage };
  }
}

export async function regenerateStoryImageAction(storyId: string, storyText: string): Promise<{ success: boolean; imageUrl?: string; error?: string }> {
  try {
    const aiResult = await aiRegenerateAIImage({ storyText });
    if (!aiResult.imageUrl) {
      throw new Error('Yapay zeka yeni bir görsel URLsi oluşturamadı.');
    }
    const updatedStory = await dbUpdateStory(storyId, { imageUrl: aiResult.imageUrl });
    if (!updatedStory) throw new Error('Görsel güncellemesi için hikaye bulunamadı');
    return { success: true, imageUrl: aiResult.imageUrl };
  } catch (error) {
    console.error("Görsel yeniden oluşturulamadı:", error);
    return { success: false, error: error instanceof Error ? error.message : 'Görsel yeniden oluşturulamadı' };
  }
}

export async function scheduleStoryPublicationAction(storyId: string, date: string, time: string): Promise<{ success: boolean; story?: Story; error?: string }> {
  try {
    const story = await dbGetStoryById(storyId);
    if (!story) {
      return { success: false, error: "Hikaye bulunamadı." };
    }
    if (story.status === 'published') {
      return { success: false, error: "Yayınlanmış hikayeler tekrar zamanlanamaz." };
    }
    const updatedStory = await dbUpdateStory(storyId, { scheduledAtDate: date, scheduledAtTime: time, status: 'pending' }); 
    if (!updatedStory) {
      return { success: false, error: "Hikaye zamanlanamadı." };
    }
    return { success: true, story: updatedStory };
  } catch (e) {
    const error = e instanceof Error ? e.message : "Bilinmeyen bir hata oluştu.";
    return { success: false, error };
  }
}

// Actions for Date-Based Scheduled Story Generation
export async function scheduleStoryGenerationAction(
  scheduledDate: string, 
  scheduledTime: string, 
  genre: StoryGenre
): Promise<{ 
  success: boolean; 
  scheduledGeneration?: ScheduledGeneration; 
  allScheduledGenerations?: ScheduledGeneration[]; 
  error?: string 
}> {
  try {
    if (!scheduledDate || !scheduledTime || !genre) {
      return { success: false, error: "Lütfen tarih, saat ve tür bilgilerini eksiksiz girin." };
    }
    // dbAddScheduledGeneration now returns the new item and the full list
    const { newScheduledGeneration, allItems } = await dbAddScheduledGeneration({ scheduledDate, scheduledTime, genre });
    return { success: true, scheduledGeneration: newScheduledGeneration, allScheduledGenerations: allItems };
  } catch (e) {
    const error = e instanceof Error ? e.message : "Planlama sırasında bir hata oluştu.";
    return { success: false, error };
  }
}

export async function processScheduledGenerationAction(id: string): Promise<{ success: boolean; story?: Story; error?: string }> {
  try {
    const scheduledItem = await dbGetScheduledGenerationById(id);
    if (!scheduledItem) {
      return { success: false, error: "Planlanmış üretim bulunamadı." };
    }
    if (scheduledItem.status === 'generated') {
      return { success: false, error: "Bu üretim zaten tamamlanmış." };
    }

    const generationResult = await generateNewStoryAction(scheduledItem.genre);

    if (generationResult.success && generationResult.story) {
      await dbUpdateScheduledGenerationStatus(id, 'generated', generationResult.story.id);
      return { success: true, story: generationResult.story };
    } else {
      await dbUpdateScheduledGenerationStatus(id, 'failed', undefined, generationResult.error || "Hikaye üretilemedi.");
      return { success: false, error: generationResult.error || "Hikaye üretilemedi." };
    }
  } catch (e) {
    const error = e instanceof Error ? e.message : "Planlanmış üretim işlenirken bir hata oluştu.";
    await dbUpdateScheduledGenerationStatus(id, 'failed', undefined, error);
    return { success: false, error };
  }
}

export async function deleteScheduledGenerationAction(id: string): Promise<{ success: boolean; error?: string; allScheduledGenerations?: ScheduledGeneration[] }> {
  try {
    const deleted = await dbDeleteScheduledGenerationById(id);
    if (!deleted) {
      return { success: false, error: "Planlanmış üretim bulunamadı veya silinemedi." };
    }
    const allItems = await dbGetScheduledGenerations();
    return { success: true, allScheduledGenerations: allItems };
  } catch (e) {
    const error = e instanceof Error ? e.message : "Silme işlemi sırasında bir hata oluştu.";
    return { success: false, error };
  }
}

// Actions for Weekly Recurring Story Generation
export async function getWeeklySchedulesAction(): Promise<{ success: boolean; schedules?: WeeklyScheduleItem[]; error?: string; }> {
  try {
    const schedules = await dbGetWeeklySchedules();
    return { success: true, schedules };
  } catch (e) {
    const error = e instanceof Error ? e.message : "Haftalık planlar getirilirken bir hata oluştu.";
    console.error("Haftalık planlar getirme hatası:", error);
    return { success: false, error };
  }
}

export async function saveWeeklyScheduleSlotAction(dayOfWeek: DayOfWeek, time: string, genre: StoryGenre | null): Promise<{ success: boolean; schedules?: WeeklyScheduleItem[]; error?: string; }> {
  try {
    if (genre) {
      await dbUpsertWeeklySchedule({ dayOfWeek, time, genre });
    } else {
      await dbDeleteWeeklyScheduleByDayTime(dayOfWeek, time);
    }
    const updatedSchedules = await dbGetWeeklySchedules();
    return { success: true, schedules: updatedSchedules };
  } catch (e) {
    const error = e instanceof Error ? e.message : "Haftalık plan yuvası kaydedilirken bir hata oluştu.";
    console.error("Haftalık plan kaydetme hatası:", error);
    return { success: false, error };
  }
}
