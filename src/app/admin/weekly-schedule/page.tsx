
// This is an autogenerated file from Firebase Studio.
'use client';

import { useEffect, useState, useTransition } from 'react';
import type { StoryGenre, WeeklyScheduleItem, DayOfWeek, Story } from '@/lib/types';
import { GENRES } from '@/lib/constants';
import { Button } from '@/components/ui/button';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { useToast } from '@/hooks/use-toast';
import { saveWeeklyScheduleSlotAction, generateNewStoryAction } from '@/lib/actions'; 
import { 
    addStory as dbAddStory,
    getLastWeeklyCheckTime, 
    setLastWeeklyCheckTime, 
    getWeeklySchedules as dbGetWeeklySchedules,
    upsertWeeklySchedule as dbUpsertWeeklySchedule,
    deleteWeeklyScheduleByDayTime as dbDeleteWeeklyScheduleByDayTime
} from '@/lib/mock-db'; 
import { Loader2, AlertTriangle, Save, Trash2, PlusCircle, Clock, Info, CheckCircle } from 'lucide-react';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
  DialogClose,
} from "@/components/ui/dialog";
import { Label } from '@/components/ui/label';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table";

const DAYS_OF_WEEK: { name: string; value: DayOfWeek }[] = [
  { name: "Pazartesi", value: 0 },
  { name: "Salı", value: 1 },
  { name: "Çarşamba", value: 2 },
  { name: "Perşembe", value: 3 },
  { name: "Cuma", value: 4 },
  { name: "Cumartesi", value: 5 },
  { name: "Pazar", value: 6 },
];

const HOURS_OF_DAY: string[] = Array.from({ length: 24 }, (_, i) => `${String(i).padStart(2, '0')}:00`);

interface ScheduleCell {
  day: DayOfWeek;
  time: string;
  genre?: StoryGenre;
  scheduleItemId?: string;
}

export default function WeeklySchedulePage() {
  const [schedules, setSchedules] = useState<WeeklyScheduleItem[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [isTransitioning, startTransition] = useTransition();
  const { toast } = useToast();

  const [isModalOpen, setIsModalOpen] = useState(false);
  const [currentCell, setCurrentCell] = useState<ScheduleCell | null>(null);
  const [selectedGenre, setSelectedGenre] = useState<StoryGenre | undefined>(undefined);
  const [isCheckingWeekly, setIsCheckingWeekly] = useState(false);

  const fetchSchedules = async (showLoadingSpinner = true) => {
    if (showLoadingSpinner) setIsLoading(true);
    setError(null);
    try {
      console.log("[WeeklyFetch] Fetching schedules from localStorage...");
      const fetchedSchedules = await dbGetWeeklySchedules();
      setSchedules(fetchedSchedules);
      console.log(`[WeeklyFetch] Fetched ${fetchedSchedules.length} schedules.`);
    } catch (e) {
      setError(e instanceof Error ? e.message : 'Haftalık planlar yüklenemedi.');
      toast({ variant: 'destructive', title: 'Yükleme Hatası', description: e instanceof Error ? e.message : 'Haftalık planlar yüklenemedi.' });
      console.error("[WeeklyFetch] Error fetching schedules:", e);
    } finally {
      if (showLoadingSpinner) setIsLoading(false);
    }
  };

  const checkAndRunWeeklyGenerations = async (isManualTrigger = false) => {
    if (isCheckingWeekly && !isManualTrigger) {
        console.log("[WeeklyGen] Already checking weekly generations, skipping.");
        return;
    }
    setIsCheckingWeekly(true);
    if(isManualTrigger) {
        toast({ title: "Haftalık Plan Kontrolü Başlatıldı", description: "Otomatik üretimler manuel olarak kontrol ediliyor..."});
    }
    console.log("[WeeklyGen] Starting checkAndRunWeeklyGenerations. Manual:", isManualTrigger);
    
    let generatedCount = 0;
    const now = new Date();
    let ranMeaningfulCheck = false;

    try {
        const currentDay = (now.getDay() + 6) % 7 as DayOfWeek; // 0 = Monday, ..., 6 = Sunday
        const currentTime = `${String(now.getHours()).padStart(2, '0')}:00`;
        console.log(`[WeeklyGen] Current Day: ${currentDay}, Current Time: ${currentTime}`);

        const allSchedulesFromDb = await dbGetWeeklySchedules(); 
        const lastCheckTimeString = await getLastWeeklyCheckTime();
        console.log(`[WeeklyGen] Last check time from localStorage: ${lastCheckTimeString}`);
        
        const oneHourInMs = 60 * 60 * 1000;
        // const oneHourInMs = 1 * 60 * 1000; // For testing: 1 minute
        const coolDownPeriodEnds = new Date(now.getTime() - oneHourInMs).toISOString();

        if (!isManualTrigger && lastCheckTimeString && new Date(lastCheckTimeString).getTime() > new Date(coolDownPeriodEnds).getTime()) {
            console.log(`[WeeklyGen] Cooldown active. Last check: ${lastCheckTimeString} is more recent than ${coolDownPeriodEnds}. Skipping.`);
            if (!isManualTrigger) { // Only show toast for automatic checks
                 toast({ title: "Haftalık Plan Kontrolü", description: "Otomatik kontrol yakın zamanda yapılmış, atlanıyor."});
            }
            setIsCheckingWeekly(false);
            return;
        }
        
        ranMeaningfulCheck = true; // Cooldown passed or manual trigger

        const dueSchedules = allSchedulesFromDb.filter(
            (s) => s.dayOfWeek === currentDay && s.time === currentTime
        );
        console.log(`[WeeklyGen] Found ${dueSchedules.length} due schedules for Day: ${currentDay}, Time: ${currentTime}.`);

        if (dueSchedules.length === 0) {
            if (isManualTrigger) { // Only show "no due" for manual trigger if cooldown passed
                toast({ title: "Haftalık Plan Kontrolü", description: "Şu an için zamanı gelmiş haftalık plan yok."});
            }
            console.log("[WeeklyGen] No due weekly schedules at this time.");
        } else {
           toast({ title: "Haftalık Plan Kontrolü", description: `${dueSchedules.length} adet zamanı gelmiş plan bulundu, üretim başlatılıyor...`});
        }

        for (const schedule of dueSchedules) {
            console.log(`[WeeklyGen] Attempting generation for schedule ID: ${schedule.id}, Genre: ${schedule.genre}, Day: ${schedule.dayOfWeek}, Time: ${schedule.time}`);
            // Call generateNewStoryAction which is a server action for AI
            const result = await generateNewStoryAction(schedule.genre); 
            console.log(`[WeeklyGen] Result for schedule ID ${schedule.id}: Success - ${result.success}, StoryData - ${!!result.storyData}, Error - ${result.error}`);
            if (result.success && result.storyData) {
                // Add story to localStorage via mock-db
                const newStory = await dbAddStory(result.storyData); 
                generatedCount++;
                toast({
                    variant: "default",
                    title: "Haftalık Hikaye Başarıyla Üretildi!",
                    description: `"${newStory.title}" (${schedule.genre}) adlı hikaye planlandığı gibi oluşturuldu ve admin panelindeki kuyruğa eklendi.`,
                    action: <CheckCircle className="text-green-500" />,
                });
                console.log(`[WeeklyGen] Successfully generated and added story: ${newStory.id} - "${newStory.title}"`);
            } else {
                toast({
                    variant: "destructive",
                    title: "Haftalık Hikaye Üretimi Başarısız",
                    description: `${schedule.genre} türündeki hikaye üretilemedi: ${result.error || 'Bilinmeyen bir hata oluştu.'}`,
                });
                 console.error(`[WeeklyGen] Failed to generate story for schedule ID ${schedule.id}. Error: ${result.error}`);
            }
        }
        
        // Only update last check time if we passed the cooldown and actually checked for due schedules
        if (ranMeaningfulCheck) {
            await setLastWeeklyCheckTime(now.toISOString());
            console.log(`[WeeklyGen] Meaningful check performed. Last check time updated to: ${now.toISOString()}`);
        }


    } catch (e) {
        console.error("[WeeklyGen] Error during weekly generation check:", e);
        toast({ variant: 'destructive', title: 'Haftalık Plan Kontrol Hatası', description: e instanceof Error ? e.message : 'Bilinmeyen bir hata oluştu.' });
    } finally {
        setIsCheckingWeekly(false);
        console.log(`[WeeklyGen] Finished checkAndRunWeeklyGenerations. Generated ${generatedCount} stories.`);
        if (generatedCount > 0) {
            // Optionally, trigger a refresh of admin page or relevant story lists if needed
            // For now, admin page refresh will pick up new stories in "pending"
        }
    }
  };


  useEffect(() => {
    fetchSchedules(); // Fetch initial schedules
    checkAndRunWeeklyGenerations(false); // Initial check on load (not manual)
    
    const intervalDuration = 30 * 60 * 1000; // 30 minutes
    // const intervalDuration = 2 * 60 * 1000; // For testing: 2 minutes
    console.log(`[WeeklyGen] Setting up interval for checkAndRunWeeklyGenerations every ${intervalDuration / (60 * 1000)} minutes.`);
    const intervalId = setInterval(() => {
        console.log("[WeeklyGen] Interval triggered: Calling checkAndRunWeeklyGenerations.");
        checkAndRunWeeklyGenerations(false); // Periodic check (not manual)
    }, intervalDuration); 
    
    return () => {
        console.log("[WeeklyGen] Clearing interval for checkAndRunWeeklyGenerations.");
        clearInterval(intervalId);
    }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  const handleCellClick = (day: DayOfWeek, time: string) => {
    console.log(`[WeeklyCellClick] Cell clicked: Day ${day}, Time ${time}`);
    const existingSchedule = schedules.find(s => s.dayOfWeek === day && s.time === time);
    setCurrentCell({ 
      day, 
      time, 
      genre: existingSchedule?.genre, 
      scheduleItemId: existingSchedule?.id 
    });
    setSelectedGenre(existingSchedule?.genre);
    setIsModalOpen(true);
    console.log(`[WeeklyCellClick] Modal opening for:`, {day, time, genre: existingSchedule?.genre, id: existingSchedule?.id});
  };

  const handleSaveSlot = () => {
    if (!currentCell) {
        console.error("[WeeklySave] Cannot save, currentCell is null.");
        return;
    }
    const { day, time } = currentCell;
    const genreToSave = selectedGenre || null; // If selectedGenre is undefined, treat as null (clear)
    console.log(`[WeeklySave] Attempting to save slot: Day ${day}, Time ${time}, Genre ${genreToSave}`);

    startTransition(async () => {
      const actionResult = await saveWeeklyScheduleSlotAction(day, time, genreToSave);
      console.log(`[WeeklySave] Server action result:`, actionResult);
      
      if (actionResult.success && actionResult.slotToSave) {
        if (actionResult.slotToSave.genre) { // Genre is being set or updated
            await dbUpsertWeeklySchedule({ 
                dayOfWeek: actionResult.slotToSave.dayOfWeek, 
                time: actionResult.slotToSave.time, 
                genre: actionResult.slotToSave.genre 
            });
            console.log(`[WeeklySave] Upserted schedule to localStorage:`, actionResult.slotToSave);
        } else { // Genre is null, so delete the schedule
            await dbDeleteWeeklyScheduleByDayTime(actionResult.slotToSave.dayOfWeek, actionResult.slotToSave.time);
            console.log(`[WeeklySave] Deleted schedule from localStorage for Day ${actionResult.slotToSave.dayOfWeek}, Time ${actionResult.slotToSave.time}`);
        }
        
        toast({ title: 'Haftalık Plan Güncellendi', description: `${DAYS_OF_WEEK.find(d=>d.value === day)?.name} ${time} için plan ${genreToSave ? genreToSave + ' olarak ayarlandı.' : 'temizlendi.'}` });
        setIsModalOpen(false);
        await fetchSchedules(false); 
      } else {
        toast({ variant: 'destructive', title: 'Kaydetme Hatası', description: actionResult.error || "Bilinmeyen bir hata oluştu." });
        console.error(`[WeeklySave] Failed to save slot. Error: ${actionResult.error}`);
      }
    });
  };
  
  const handleClearSlot = () => {
    if (!currentCell) {
        console.error("[WeeklyClear] Cannot clear, currentCell is null.");
        return;
    }
    const { day, time } = currentCell;
    console.log(`[WeeklyClear] Attempting to clear slot: Day ${day}, Time ${time}`);
    setSelectedGenre(undefined); // Ensure selectedGenre is cleared for saving logic
    
    // We call handleSaveSlot, which will now see selectedGenre as undefined (or null after the next line)
    // and thus interpret it as a clear/delete operation.
    // This reuses the existing save logic where genreToSave will be null.
    handleSaveSlot(); 
  }

  if (isLoading) {
    return (
      <div className="flex justify-center items-center min-h-[calc(100vh-200px)]">
        <Loader2 className="h-12 w-12 animate-spin text-primary" />
        <p className="ml-4 text-lg text-muted-foreground">Haftalık plan yükleniyor...</p>
      </div>
    );
  }

  if (error) {
    return (
      <div className="text-center py-10 text-red-600 bg-red-50 p-6 rounded-lg shadow-md">
        <AlertTriangle className="mx-auto h-12 w-12 mb-4" />
        <h2 className="text-2xl font-semibold mb-2">Plan Yüklenirken Hata Oluştu</h2>
        <p>{error}</p>
        <Button onClick={() => { fetchSchedules(true); checkAndRunWeeklyGenerations(true); }} variant="destructive" className="mt-4">Tekrar Dene ve Kontrol Et</Button>
      </div>
    );
  }

  return (
    <div className="space-y-8">
      <div className="flex flex-col sm:flex-row justify-between items-center gap-4">
        <h1 className="text-3xl md:text-4xl font-bold text-foreground tracking-tight">Haftalık Hikaye Üretim Planı</h1>
         <Button onClick={() => checkAndRunWeeklyGenerations(true)} disabled={isCheckingWeekly || isTransitioning} variant="outline">
          {isCheckingWeekly ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <Clock className="mr-2 h-4 w-4" />}
          Şimdi Haftalık Planı Kontrol Et
        </Button>
      </div>
       <div className="bg-blue-50 border-l-4 border-blue-500 text-blue-700 p-4 rounded-md shadow" role="alert">
        <div className="flex items-center">
          <Info className="h-6 w-6 mr-3" />
          <div>
            <p className="font-bold">Otomatik Haftalık Üretim Bilgisi</p>
            <p className="text-sm">Bu sayfada tanımlanan haftalık planlar, belirtilen gün ve saatlerde otomatik hikaye üretimleri için bir şablondur. Bu sayfa açıkken, yaklaşık saat başlarında (veya 30 dk aralıklarla) veya "Şimdi Haftalık Planı Kontrol Et" butonuna tıklandığında, zamanı gelmiş ve son bir saat içinde işlenmemiş planlar için hikaye üretimi tetiklenmeye çalışılır. Üretilen hikayeler admin panelindeki "Hikaye Kuyruğu" bölümüne "Beklemede" olarak eklenir. Veriler tarayıcınızın yerel depolamasında saklanır.</p>
          </div>
        </div>
      </div>

      <div className="overflow-x-auto bg-card p-4 sm:p-6 rounded-lg shadow-lg">
        <Table className="min-w-full border-collapse">
          <TableHeader>
            <TableRow className="bg-muted/50">
              <TableHead className="w-24 sticky left-0 bg-card z-10 py-3 px-4 font-semibold text-foreground">Saat</TableHead>
              {DAYS_OF_WEEK.map(day => (
                <TableHead key={day.value} className="py-3 px-4 text-center font-semibold text-foreground whitespace-nowrap">{day.name}</TableHead>
              ))}
            </TableRow>
          </TableHeader>
          <TableBody>
            {HOURS_OF_DAY.map(hour => (
              <TableRow key={hour} className="hover:bg-muted/20 transition-colors duration-150 group">
                <TableCell className="sticky left-0 bg-card group-hover:bg-muted/20 py-3 px-4 font-medium text-muted-foreground z-10 whitespace-nowrap">{hour}</TableCell>
                {DAYS_OF_WEEK.map(day => {
                  const schedule = schedules.find(s => s.dayOfWeek === day.value && s.time === hour);
                  return (
                    <TableCell 
                      key={`${day.value}-${hour}`} 
                      className="py-2 px-1.5 text-center border cursor-pointer hover:bg-accent/20 transition-colors duration-150 h-16"
                      onClick={() => handleCellClick(day.value, hour)}
                      title={`${day.name} ${hour} için plan ${schedule ? `'${schedule.genre}' düzenle` : 'oluştur'}`}
                    >
                      {schedule ? (
                        <div className="bg-primary/10 text-primary font-medium p-2 rounded-md text-xs h-full flex items-center justify-center">
                          {schedule.genre}
                        </div>
                      ) : (
                        <div className="text-muted-foreground/50 hover:text-primary h-full flex items-center justify-center">
                          <PlusCircle className="h-5 w-5"/>
                        </div>
                      )}
                    </TableCell>
                  );
                })}
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </div>

      {currentCell && (
        <Dialog open={isModalOpen} onOpenChange={setIsModalOpen}>
          <DialogContent className="sm:max-w-[425px]">
            <DialogHeader>
              <DialogTitle>Planı Düzenle: {DAYS_OF_WEEK.find(d=>d.value === currentCell.day)?.name} - {currentCell.time}</DialogTitle>
              <DialogDescription>
                Bu zaman dilimi için bir hikaye türü seçin veya mevcut planı temizlemek için türü boş bırakıp kaydedin.
              </DialogDescription>
            </DialogHeader>
            <div className="grid gap-4 py-4">
              <div className="grid grid-cols-4 items-center gap-4">
                <Label htmlFor="genre-select-modal" className="text-right col-span-1">
                  Tür
                </Label>
                <div className="col-span-3">
                  <Select 
                    value={selectedGenre || ""} // Use empty string for placeholder if undefined
                    onValueChange={(value) => setSelectedGenre(value === "" ? undefined : value as StoryGenre)} // Set to undefined if ""
                  >
                    <SelectTrigger id="genre-select-modal">
                      <SelectValue placeholder="Tür seçilmedi (Planı temizle)" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="">Tür seçilmedi (Planı temizle)</SelectItem>
                      {GENRES.map(g => <SelectItem key={g} value={g}>{g}</SelectItem>)}
                    </SelectContent>
                  </Select>
                </div>
              </div>
            </div>
            <DialogFooter className="flex-col sm:flex-row sm:justify-end gap-2">
               {/* Removed separate clear button, integrated into save logic */}
              <DialogClose asChild>
                <Button variant="outline" disabled={isTransitioning}>İptal</Button>
              </DialogClose>
              <Button 
                onClick={handleSaveSlot} 
                disabled={isTransitioning || selectedGenre === currentCell.genre}
              >
                {isTransitioning ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <Save className="mr-2 h-4 w-4" />}
                {selectedGenre ? "Kaydet" : "Planı Temizle"}
              </Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>
      )}
    </div>
  );
}

