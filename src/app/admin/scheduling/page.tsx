
// This is an autogenerated file from Firebase Studio.
'use client';

import { useEffect, useState, useTransition } from 'react';
import Link from 'next/link';
import type { ScheduledGeneration, StoryGenre, Story } from '@/lib/types';
import { getScheduledGenerations } from '@/lib/mock-db';
import { GENRES } from '@/lib/constants';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Input } from '@/components/ui/input';
import { Calendar } from '@/components/ui/calendar';
import { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';
import { useToast } from '@/hooks/use-toast';
import { scheduleStoryGenerationAction, processScheduledGenerationAction, deleteScheduledGenerationAction } from '@/lib/actions';
import { Loader2, AlertTriangle, CalendarPlus, CalendarClock, Trash2, Wand2, CheckCircle, XCircle, Info, CalendarCheck2, RefreshCw } from 'lucide-react';
import { format, parseISO, isValid } from 'date-fns';
import { tr } from 'date-fns/locale';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog";
import { Label } from '@/components/ui/label';
import { Badge } from '@/components/ui/badge';
import { Separator } from '@/components/ui/separator';

export default function SchedulingPage() {
  const [scheduledGenerations, setScheduledGenerations] = useState<ScheduledGeneration[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [isTransitioning, startTransition] = useTransition();
  const { toast } = useToast();

  const [newScheduleDate, setNewScheduleDate] = useState<Date | undefined>(new Date());
  const [newScheduleTime, setNewScheduleTime] = useState<string>("10:00");
  const [newScheduleGenre, setNewScheduleGenre] = useState<StoryGenre | undefined>(undefined);
  
  const [autoProcessingAttemptedOnLoad, setAutoProcessingAttemptedOnLoad] = useState(false);


  const fetchScheduledItems = async (isManualRefresh = false) => {
    if(!isManualRefresh && !autoProcessingAttemptedOnLoad) {
      setIsLoading(true); 
    } else if (isManualRefresh && !isTransitioning) { 
      // Only start transition for manual refresh if not already in one (e.g. from add/delete)
      // This prevents nested transitions.
      // startTransition(() => {}); // Re-evaluating if this is needed here for button refresh
    }
    setError(null);
    try {
      let items = await getScheduledGenerations();
      const now = new Date();
      
      const dueItems = items.filter(item => {
        if (item.status !== 'pending') return false;
        try {
          const scheduledDateTime = parseISO(`${item.scheduledDate}T${item.scheduledTime}`);
          return isValid(scheduledDateTime) && scheduledDateTime <= now;
        } catch (e) {
          console.error("Error parsing scheduled date/time for item:", item.id, e);
          return false; 
        }
      });

      if (dueItems.length > 0 && (isManualRefresh || !autoProcessingAttemptedOnLoad)) {
        const toastTitle = isManualRefresh ? "Manuel Üretim Kontrolü" : "Otomatik Üretim Kontrolü";
        if(isManualRefresh || !autoProcessingAttemptedOnLoad){ // Show toast only if processing is expected
            toast({
                title: toastTitle,
                description: `${dueItems.length} adet zamanı gelmiş planlı üretim işleniyor... Bu işlem biraz sürebilir.`,
            });
        }

        const processingPromises = dueItems.map(async (item) => {
          try {
            const result = await processScheduledGenerationAction(item.id);
            if (result.success && result.story) {
              toast({
                variant: "default",
                title: "Otomatik Hikaye Üretildi!",
                description: `"${result.story.title}" (${item.genre}) başarıyla oluşturuldu. Admin paneline giderek görebilirsiniz.`,
                action: <CheckCircle className="text-green-500" />,
              });
            } else if (result.success && !result.story) { 
               toast({
                variant: "destructive",
                title: "Otomatik Üretim Sorunu",
                description: `${item.genre} türündeki hikaye üretildi ancak detayları alınamadı. Lütfen kontrol edin.`,
              });
            }
            else { 
              toast({
                variant: "destructive",
                title: "Otomatik Üretim Başarısız",
                description: `${item.genre} türündeki zamanlanmış hikaye üretilemedi: ${result.error || 'Bilinmeyen bir hata oluştu.'}`,
              });
            }
          } catch (e) {
             toast({
                variant: "destructive",
                title: "Otomatik Üretim Hatası",
                description: `${item.genre} türündeki zamanlanmış hikaye işlenirken bir hata oluştu: ${e instanceof Error ? e.message : String(e)}`,
              });
          }
        });
        await Promise.allSettled(processingPromises);
        
        if (!autoProcessingAttemptedOnLoad && !isManualRefresh) setAutoProcessingAttemptedOnLoad(true);
        items = await getScheduledGenerations(); 
      }
      
      setScheduledGenerations(items);
    } catch (e) {
      setError(e instanceof Error ? e.message : 'Planlanmış üretimler yüklenemedi.');
      console.error(e);
    } finally {
      if(!isManualRefresh && !autoProcessingAttemptedOnLoad && isLoading) setIsLoading(false);
    }
  };
  
  useEffect(() => {
    fetchScheduledItems(false);
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []); 

  const handleAddScheduledGeneration = () => {
    if (!newScheduleDate || !newScheduleTime || !newScheduleGenre) {
      toast({ variant: 'destructive', title: 'Eksik Bilgi', description: 'Lütfen tarih, saat ve tür seçin.' });
      return;
    }
    const dateString = format(newScheduleDate, 'yyyy-MM-dd');
    startTransition(async () => {
      const result = await scheduleStoryGenerationAction(dateString, newScheduleTime, newScheduleGenre);
      if (result.success && result.allScheduledGenerations && result.scheduledGeneration) {
        toast({ 
          title: 'Hikaye Üretimi Planlandı', 
          description: `${result.scheduledGeneration.genre} türünde hikaye ${formatDateDisplay(result.scheduledGeneration.scheduledDate, result.scheduledGeneration.scheduledTime)} için planlandı.` 
        });
        setScheduledGenerations(result.allScheduledGenerations); 
        setNewScheduleDate(new Date());
        setNewScheduleTime("10:00");
        setNewScheduleGenre(undefined);
      } else if (result.success && result.scheduledGeneration) { // Fallback if allScheduledGenerations is missing
        toast({ 
          title: 'Hikaye Üretimi Planlandı (Liste yenileniyor)', 
          description: `${result.scheduledGeneration.genre} türünde hikaye ${formatDateDisplay(result.scheduledGeneration.scheduledDate, result.scheduledGeneration.scheduledTime)} için planlandı. Liste birazdan güncellenecektir.` 
        });
        fetchScheduledItems(true); // Refetch as a fallback
        setNewScheduleDate(new Date());
        setNewScheduleTime("10:00");
        setNewScheduleGenre(undefined);
      }
      else {
        toast({ variant: 'destructive', title: 'Planlama Başarısız', description: result.error });
      }
    });
  };

  const handleProcessGeneration = (id: string) => {
    startTransition(async () => {
      const itemToProcess = scheduledGenerations.find(item => item.id === id);
      toast({
        title: "Manuel Üretim Başlatıldı",
        description: `"${itemToProcess?.genre}" türündeki hikaye şimdi üretiliyor...`
      });
      const result = await processScheduledGenerationAction(id);
      if (result.success && result.story) {
        toast({ title: 'Hikaye Üretildi!', description: `"${result.story.title}" başarıyla oluşturuldu. Admin panelinde görebilirsiniz.` });
      } else {
        toast({ variant: 'destructive', title: 'Üretim Başarısız', description: result.error });
      }
      fetchScheduledItems(true); 
    });
  };

  const handleDeleteGeneration = (id: string, genre: StoryGenre, date: string, time: string) => {
    startTransition(async () => {
      const result = await deleteScheduledGenerationAction(id);
      if (result.success && result.allScheduledGenerations) {
        toast({ title: 'Plan Silindi', description: `${genre} türündeki ${formatDateDisplay(date, time)} tarihli plan silindi.` });
        setScheduledGenerations(result.allScheduledGenerations); 
      } else {
        toast({ variant: 'destructive', title: 'Silme Başarısız', description: result.error });
        fetchScheduledItems(true); 
      }
    });
  };

  const formatDateDisplay = (dateString?: string, timeString?: string) => {
    if (!dateString) return 'N/A';
    try {
      const datePart = parseISO(dateString); // Expects YYYY-MM-DD
      if (!isValid(datePart)) return 'Geçersiz Tarih';
      
      let hours = 0;
      let minutes = 0;

      if (timeString) { // Expects HH:MM
        const timeParts = timeString.split(':');
        if (timeParts.length === 2) {
          const parsedHours = parseInt(timeParts[0], 10);
          const parsedMinutes = parseInt(timeParts[1], 10);
          if (!isNaN(parsedHours) && parsedHours >= 0 && parsedHours <= 23) {
            hours = parsedHours;
          }
          if (!isNaN(parsedMinutes) && parsedMinutes >= 0 && parsedMinutes <= 59) {
            minutes = parsedMinutes;
          }
        }
      }
      // Combine date with parsed time for formatting
      const dateTimeToFormat = new Date(datePart.getFullYear(), datePart.getMonth(), datePart.getDate(), hours, minutes);
      return format(dateTimeToFormat, 'dd MMMM yyyy, HH:mm', { locale: tr });

    } catch (e) {
      console.error("Error formatting date display:", dateString, timeString, e);
      return `${dateString} ${timeString || ''} (Hatalı Format)`.trim();
    }
  };
  
  const formatCreatedAtDisplay = (isoDateString?: string) => {
    if (!isoDateString) return 'N/A';
    try {
      const date = parseISO(isoDateString);
      if(!isValid(date)) return 'Geçersiz Oluşturulma Tarihi';
      return format(date, 'dd MMMM yyyy, HH:mm', { locale: tr });
    } catch (e) {
      return 'Hatalı Oluşturulma Tarihi';
    }
  };


  const getStatusBadge = (status: ScheduledGeneration['status']) => {
    switch (status) {
      case 'pending':
        return <Badge variant="outline" className="bg-yellow-100 text-yellow-700 border-yellow-300"><CalendarClock className="mr-1 h-3 w-3" />Beklemede</Badge>;
      case 'generated':
        return <Badge variant="outline" className="bg-green-100 text-green-700 border-green-300"><CheckCircle className="mr-1 h-3 w-3" />Üretildi</Badge>;
      case 'failed':
        return <Badge variant="destructive"><XCircle className="mr-1 h-3 w-3" />Başarısız</Badge>;
      default:
        return <Badge variant="secondary">Bilinmiyor</Badge>;
    }
  };
  
  if (isLoading && !autoProcessingAttemptedOnLoad && scheduledGenerations.length === 0) { 
    return (
      <div className="flex justify-center items-center min-h-[calc(100vh-200px)]">
        <Loader2 className="h-12 w-12 animate-spin text-primary" />
        <p className="ml-4 text-lg text-muted-foreground">Planlar yükleniyor ve otomatik üretimler kontrol ediliyor...</p>
      </div>
    );
  }

  if (error) {
    return (
      <div className="text-center py-10 text-red-600 bg-red-50 p-6 rounded-lg shadow-md">
        <AlertTriangle className="mx-auto h-12 w-12 mb-4" />
        <h2 className="text-2xl font-semibold mb-2">Planlar Yüklenirken Hata Oluştu</h2>
        <p>{error}</p>
        <Button onClick={() => fetchScheduledItems(true)} variant="destructive" className="mt-4">
          <RefreshCw className="mr-2 h-4 w-4" /> Tekrar Dene
        </Button>
      </div>
    );
  }

  return (
    <div className="space-y-8">
      <div className="flex flex-col sm:flex-row justify-between items-center gap-4">
        <h1 className="text-3xl md:text-4xl font-bold text-foreground tracking-tight">Hikaye Üretim Planlayıcısı</h1>
         <Button variant="outline" asChild>
          <Link href="/admin">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="mr-2 h-4 w-4"><path d="m12 19-7-7 7-7"/><path d="M19 12H5"/></svg>
            Admin Paneline Dön
          </Link>
        </Button>
      </div>
      
      <div className="bg-blue-50 border-l-4 border-blue-500 text-blue-700 p-4 rounded-md shadow" role="alert">
        <div className="flex items-center">
          <Info className="h-6 w-6 mr-3" />
          <div>
            <p className="font-bold">Otomatik Üretim Bilgisi</p>
            <p className="text-sm">Bu sayfa yüklendiğinde veya "Yenile" butonuna tıklandığında, zamanı gelmiş "beklemede" olan planlar otomatik olarak işlenmeye çalışılır. Veriler tarayıcınızın yerel depolamasında saklandığı için, bu işlemler yalnızca bu sayfa açıkken ve tarayıcınız çalışırken gerçekleşir. Sürekli bir arka plan kontrolü bulunmamaktadır.</p>
          </div>
        </div>
      </div>


      <Card className="shadow-lg">
        <CardHeader>
          <CardTitle className="text-2xl flex items-center">
            <CalendarPlus className="mr-3 h-7 w-7 text-primary" />
            Yeni Hikaye Üretimi Planla
          </CardTitle>
          <CardDescription>Belirli bir tarih, saat ve tür için otomatik hikaye üretimi planlayın.</CardDescription>
        </CardHeader>
        <CardContent className="space-y-6">
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4 items-end">
            <div>
              <Label htmlFor="new-schedule-date" className="block mb-1 font-medium">Tarih</Label>
              <Popover>
                <PopoverTrigger asChild>
                  <Button
                    id="new-schedule-date"
                    variant={"outline"}
                    className={`w-full justify-start text-left font-normal ${!newScheduleDate && "text-muted-foreground"}`}
                  >
                    <CalendarClock className="mr-2 h-4 w-4" />
                    {newScheduleDate ? format(newScheduleDate, "PPP", { locale: tr }) : <span>Bir tarih seçin</span>}
                  </Button>
                </PopoverTrigger>
                <PopoverContent className="w-auto p-0">
                  <Calendar
                    mode="single"
                    selected={newScheduleDate}
                    onSelect={setNewScheduleDate}
                    initialFocus
                    locale={tr}
                    disabled={(date) => date < new Date(new Date().setHours(0,0,0,0))} 
                  />
                </PopoverContent>
              </Popover>
            </div>
            <div>
              <Label htmlFor="new-schedule-time" className="block mb-1 font-medium">Saat</Label>
              <Input
                id="new-schedule-time"
                type="time"
                value={newScheduleTime}
                onChange={(e) => setNewScheduleTime(e.target.value)}
                className="w-full"
              />
            </div>
            <div>
              <Label htmlFor="new-schedule-genre" className="block mb-1 font-medium">Tür</Label>
              <Select value={newScheduleGenre} onValueChange={(value) => setNewScheduleGenre(value as StoryGenre)}>
                <SelectTrigger id="new-schedule-genre" className="w-full">
                  <SelectValue placeholder="Bir tür seçin..." />
                </SelectTrigger>
                <SelectContent>
                  {GENRES.map(g => <SelectItem key={g} value={g}>{g}</SelectItem>)}
                </SelectContent>
              </Select>
            </div>
          </div>
          <Button onClick={handleAddScheduledGeneration} disabled={isTransitioning || !newScheduleDate || !newScheduleTime || !newScheduleGenre} className="w-full md:w-auto">
            {isTransitioning ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <CalendarCheck2 className="mr-2 h-4 w-4" />}
            Üretimi Planla
          </Button>
        </CardContent>
      </Card>

      <Separator className="my-8" />

       <div className="flex items-center mb-6">
        <h2 className="text-2xl md:text-3xl font-semibold text-foreground tracking-tight">
          Planlanmış Üretimler ({scheduledGenerations.length})
        </h2>
        <Button onClick={() => fetchScheduledItems(true)} variant="ghost" size="icon" className="ml-2" disabled={isTransitioning || (isLoading && autoProcessingAttemptedOnLoad) }>
            <RefreshCw className={`h-5 w-5 ${(isTransitioning || (isLoading && autoProcessingAttemptedOnLoad)) ? 'animate-spin' : ''}`} />
        </Button>
      </div>

      {(isLoading && scheduledGenerations.length === 0 && !autoProcessingAttemptedOnLoad) ? (
         <div className="flex justify-center items-center min-h-[200px]">
            <Loader2 className="h-8 w-8 animate-spin text-primary" />
            <p className="ml-3 text-muted-foreground">Planlar yükleniyor...</p>
        </div>
      ) : scheduledGenerations.length === 0 ? (
        <div className="text-center py-10 text-muted-foreground bg-card p-6 rounded-lg shadow">
          <Info className="mx-auto h-12 w-12 mb-4" />
          <p className="text-lg">Henüz planlanmış bir hikaye üretimi yok.</p>
          <p>Yukarıdaki formu kullanarak yeni üretimler planlayabilirsiniz.</p>
        </div>
      ) : (
        <div className="space-y-4">
          {scheduledGenerations.map(item => (
            <Card key={item.id} className="shadow-md hover:shadow-lg transition-shadow">
              <CardHeader>
                <CardTitle className="flex justify-between items-center">
                  <span>{item.genre} Türünde Hikaye</span>
                  {getStatusBadge(item.status)}
                </CardTitle>
                <CardDescription>
                  Planlanan Zaman: {formatDateDisplay(item.scheduledDate, item.scheduledTime)}
                  <br/>
                  Oluşturulma Tarihi: {formatCreatedAtDisplay(item.createdAt)}
                </CardDescription>
              </CardHeader>
              {item.status === 'failed' && item.errorMessage && (
                 <CardContent>
                    <p className="text-sm text-destructive bg-red-50 p-3 rounded-md"><strong>Hata:</strong> {item.errorMessage}</p>
                 </CardContent>
              )}
              {item.status === 'generated' && item.generatedStoryId && (
                 <CardContent>
                    <p className="text-sm text-green-700 bg-green-50 p-3 rounded-md">
                        Hikaye üretildi. İlgili hikayeyi Admin panelindeki "Hikaye Kuyruğu" bölümünde bulabilirsiniz.
                    </p>
                 </CardContent>
              )}
              <CardFooter className="flex flex-wrap justify-end gap-2">
                {item.status === 'pending' && (
                  <Button onClick={() => handleProcessGeneration(item.id)} disabled={isTransitioning} variant="default">
                    {isTransitioning && scheduledGenerations.find(s => s.id === item.id)?.status !== 'pending' ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <Wand2 className="mr-2 h-4 w-4" />}
                    Şimdi Üret
                  </Button>
                )}
                 {item.status === 'failed' && ( 
                  <Button onClick={() => handleProcessGeneration(item.id)} disabled={isTransitioning} variant="outline">
                    {isTransitioning && scheduledGenerations.find(s => s.id === item.id)?.status !== 'failed' ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <RefreshCw className="mr-2 h-4 w-4" />}
                    Tekrar Dene
                  </Button>
                )}
                <AlertDialog>
                  <AlertDialogTrigger asChild>
                    <Button variant="destructive" disabled={isTransitioning}>
                      <Trash2 className="mr-2 h-4 w-4" /> Sil
                    </Button>
                  </AlertDialogTrigger>
                  <AlertDialogContent>
                    <AlertDialogHeader>
                      <AlertDialogTitle>Bu planı silmek istediğinize emin misiniz?</AlertDialogTitle>
                      <AlertDialogDescription>
                        {item.genre} türü için {formatDateDisplay(item.scheduledDate, item.scheduledTime)} tarihli üretim planı kalıcı olarak silinecektir. Bu işlem geri alınamaz.
                      </AlertDialogDescription>
                    </AlertDialogHeader>
                    <AlertDialogFooter>
                      <AlertDialogCancel disabled={isTransitioning}>İptal</AlertDialogCancel>
                      <AlertDialogAction
                        onClick={() => handleDeleteGeneration(item.id, item.genre, item.scheduledDate, item.scheduledTime)}
                        className="bg-destructive hover:bg-destructive/90"
                        disabled={isTransitioning}
                      >
                        {isTransitioning ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : null}
                        Evet, Planı Sil
                      </AlertDialogAction>
                    </AlertDialogFooter>
                  </AlertDialogContent>
                </AlertDialog>
              </CardFooter>
            </Card>
          ))}
        </div>
      )}
    </div>
  );
}
    