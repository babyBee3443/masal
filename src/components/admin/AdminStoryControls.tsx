// This is an autogenerated file from Firebase Studio.
'use client';

import { useState, useTransition, useEffect } from 'react';
import Image from 'next/image';
import type { Story, StoryGenre } from '@/lib/types';
import { GENRES } from '@/lib/constants';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Textarea } from '@/components/ui/textarea';
import { Input } from '@/components/ui/input';
import { Calendar } from '@/components/ui/calendar';
import { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';
import { useToast } from '@/hooks/use-toast';
import { publishStoryAction, deleteStoryAction, updateStoryCategoryAction, regenerateStoryImageAction, scheduleStoryPublicationAction } from '@/lib/actions';
import { CheckCircle, Trash2, RefreshCw, Loader2, CalendarClock, Edit } from 'lucide-react';
import { format, parseISO } from 'date-fns';
import { tr } from 'date-fns/locale';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
  DialogClose,
} from "@/components/ui/dialog";
import { Label } from '@/components/ui/label';


interface AdminStoryControlsProps {
  story: Story;
  onStoryUpdate: () => void;
}

export function AdminStoryControls({ story: initialStory, onStoryUpdate }: AdminStoryControlsProps) {
  const [story, setStory] = useState(initialStory);
  const [isPending, startTransition] = useTransition();
  const { toast } = useToast();

  const [isSchedulingDialogOpen, setIsSchedulingDialogOpen] = useState(false);
  const [scheduledDate, setScheduledDate] = useState<Date | undefined>(
    initialStory.scheduledAtDate ? parseISO(initialStory.scheduledAtDate) : undefined
  );
  const [scheduledTime, setScheduledTime] = useState<string>(initialStory.scheduledAtTime || "10:00");

  useEffect(() => {
    setStory(initialStory);
    setScheduledDate(initialStory.scheduledAtDate ? parseISO(initialStory.scheduledAtDate) : undefined);
    setScheduledTime(initialStory.scheduledAtTime || "10:00");
  }, [initialStory]);


  const handlePublish = () => {
    startTransition(async () => {
      const result = await publishStoryAction(story.id);
      if (result.success && result.story) {
        setStory(result.story); // Update local state
        toast({ title: 'Hikaye Yayınlandı', description: `"${result.story.title}" artık yayında.` });
        onStoryUpdate(); // Notify parent
      } else {
        toast({ variant: 'destructive', title: 'Yayınlama Hatası', description: result.error });
      }
    });
  };

  const handleDelete = () => {
    startTransition(async () => {
      const result = await deleteStoryAction(story.id);
      if (result.success) {
        toast({ title: 'Hikaye Silindi', description: `"${story.title}" silindi.` });
        onStoryUpdate(); // Notify parent to remove/refresh
      } else {
        toast({ variant: 'destructive', title: 'Silme Hatası', description: result.error });
      }
    });
  };

  const handleCategoryChange = (newGenre: StoryGenre) => {
    startTransition(async () => {
      const result = await updateStoryCategoryAction(story.id, newGenre);
      if (result.success && result.story) {
        setStory(result.story);
        toast({ title: 'Kategori Güncellendi', description: `"${result.story.title}" hikayesinin kategorisi ${newGenre} olarak değiştirildi.` });
        onStoryUpdate();
      } else {
        toast({ variant: 'destructive', title: 'Kategori Güncelleme Hatası', description: result.error });
      }
    });
  };

  const handleRegenerateImage = () => {
    startTransition(async () => {
      const result = await regenerateStoryImageAction(story.id, story.content);
      if (result.success && result.imageUrl) {
        setStory(prev => ({ ...prev, imageUrl: result.imageUrl! }));
        toast({ title: 'Görsel Yeniden Oluşturuldu', description: `"${story.title}" için yeni görsel oluşturuldu.` });
        onStoryUpdate(); 
      } else {
        toast({ variant: 'destructive', title: 'Görsel Yeniden Oluşturma Hatası', description: result.error });
      }
    });
  };

  const handleSchedulePublication = () => {
    if (!scheduledDate || !scheduledTime) {
      toast({ variant: 'destructive', title: 'Zamanlama Hatası', description: 'Lütfen geçerli bir tarih ve saat seçin.' });
      return;
    }
    const dateString = format(scheduledDate, 'yyyy-MM-dd');
    startTransition(async () => {
      const result = await scheduleStoryPublicationAction(story.id, dateString, scheduledTime);
      if (result.success && result.story) {
        setStory(result.story);
        toast({ title: 'Hikaye Zamanlandı', description: `"${result.story.title}" ${format(scheduledDate, 'dd MMMM yyyy', {locale: tr})} ${scheduledTime} için zamanlandı.`});
        setIsSchedulingDialogOpen(false);
        onStoryUpdate();
      } else {
        toast({ variant: 'destructive', title: 'Zamanlama Hatası', description: result.error });
      }
    });
  };
  
  const formatDateDisplay = (dateString?: string, timeString?: string) => {
    if (!dateString) return 'Zamanlanmamış';
    try {
      const date = parseISO(dateString);
      let formatted = format(date, 'dd MMMM yyyy', { locale: tr });
      if (timeString) {
        formatted += ` ${timeString}`;
      }
      return formatted;
    } catch (e) {
      return 'Geçersiz Tarih';
    }
  }
  
  const formatSimpleDate = (dateString?: string) => {
    if (!dateString) return 'N/A';
    try {
      return format(parseISO(dateString), 'dd MMMM yyyy, HH:mm', {locale: tr});
    } catch (e) {
       return new Date(dateString).toLocaleDateString('tr-TR', { year: 'numeric', month: 'long', day: 'numeric', hour: '2-digit', minute: '2-digit' });
    }
  }


  return (
    <Card className="w-full shadow-lg animate-fadeIn">
      <CardHeader>
        <CardTitle className="text-2xl">{story.title}</CardTitle>
        <CardDescription>
          Durum: <span className={`font-semibold ${story.status === 'published' ? 'text-green-600' : 'text-orange-500'}`}>{story.status === 'published' ? 'Yayınlandı' : 'Beklemede'}</span>
          <span className="mx-2">|</span>
          Tür: {story.genre}
          <br />
          Oluşturulma: {formatSimpleDate(story.createdAt)}
          {story.status === 'published' && story.publishedAt && (
            <> | Yayınlanma: {formatSimpleDate(story.publishedAt)}</>
          )}
           {story.status === 'pending' && story.scheduledAtDate && (
            <> | Planlanan Yayın: <span className="font-semibold text-blue-600">{formatDateDisplay(story.scheduledAtDate, story.scheduledAtTime)}</span></>
          )}
        </CardDescription>
      </CardHeader>
      <CardContent className="grid md:grid-cols-3 gap-6">
        <div className="md:col-span-1">
           <Image
            src={story.imageUrl || `https://placehold.co/600x480.png`}
            alt={`${story.title} için görsel`}
            width={600}
            height={480}
            className="rounded-lg object-cover w-full aspect-[4/3] shadow-md"
            data-ai-hint="story illustration fantasy"
          />
          <Button onClick={handleRegenerateImage} disabled={isPending} className="w-full mt-4" variant="outline">
            {isPending && story.imageUrl !== initialStory.imageUrl ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <RefreshCw className="mr-2 h-4 w-4" />}
            Görseli Yeniden Oluştur
          </Button>
        </div>
        <div className="md:col-span-2 space-y-4">
          <div>
            <Label htmlFor={`summary-${story.id}`} className="text-sm font-medium text-muted-foreground block mb-1">Özet</Label>
             <Textarea
                id={`summary-${story.id}`}
                value={story.summary}
                readOnly
                className="h-24 bg-muted/50"
              />
          </div>
           <div>
            <Label htmlFor={`content-${story.id}`} className="text-sm font-medium text-muted-foreground block mb-1">Tam İçerik</Label>
             <Textarea
                id={`content-${story.id}`}
                value={story.content}
                readOnly
                className="h-40 bg-muted/50"
              />
          </div>
          <div>
            <Label htmlFor={`category-${story.id}`} className="text-sm font-medium text-muted-foreground block mb-1">Kategoriyi Değiştir</Label>
            <Select value={story.genre} onValueChange={(value) => handleCategoryChange(value as StoryGenre)} disabled={isPending}>
              <SelectTrigger id={`category-${story.id}`} className="w-full">
                <SelectValue placeholder="Tür seçin" />
              </SelectTrigger>
              <SelectContent>
                {GENRES.map(g => <SelectItem key={g} value={g}>{g}</SelectItem>)}
              </SelectContent>
            </Select>
          </div>
        </div>
      </CardContent>
      <CardFooter className="flex flex-wrap justify-end space-x-3 gap-y-2">
        {story.status === 'pending' && (
          <>
            <Button onClick={handlePublish} disabled={isPending} className="bg-green-600 hover:bg-green-700 text-white">
              {isPending && story.status === 'published' ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <CheckCircle className="mr-2 h-4 w-4" />}
              Şimdi Yayınla
            </Button>
            <Dialog open={isSchedulingDialogOpen} onOpenChange={setIsSchedulingDialogOpen}>
              <DialogTrigger asChild>
                <Button variant="outline" disabled={isPending}>
                  <CalendarClock className="mr-2 h-4 w-4" />
                  {story.scheduledAtDate ? 'Zamanlamayı Düzenle' : 'Yayın Zamanla'}
                </Button>
              </DialogTrigger>
              <DialogContent className="sm:max-w-[425px]">
                <DialogHeader>
                  <DialogTitle>Hikaye Yayınını Zamanla</DialogTitle>
                  <DialogDescription>
                    "{story.title}" hikayesinin ne zaman yayınlanacağını seçin.
                  </DialogDescription>
                </DialogHeader>
                <div className="grid gap-4 py-4">
                  <div className="grid grid-cols-4 items-center gap-4">
                    <Label htmlFor="schedule-date" className="text-right">
                      Tarih
                    </Label>
                    <Popover>
                      <PopoverTrigger asChild>
                        <Button
                          variant={"outline"}
                          className={`col-span-3 justify-start text-left font-normal ${!scheduledDate && "text-muted-foreground"}`}
                        >
                          <CalendarClock className="mr-2 h-4 w-4" />
                          {scheduledDate ? format(scheduledDate, "PPP", {locale: tr}) : <span>Bir tarih seçin</span>}
                        </Button>
                      </PopoverTrigger>
                      <PopoverContent className="w-auto p-0">
                        <Calendar
                          mode="single"
                          selected={scheduledDate}
                          onSelect={setScheduledDate}
                          initialFocus
                          locale={tr}
                          disabled={(date) => date < new Date(new Date().setHours(0,0,0,0))} // Disable past dates
                        />
                      </PopoverContent>
                    </Popover>
                  </div>
                  <div className="grid grid-cols-4 items-center gap-4">
                    <Label htmlFor="schedule-time" className="text-right">
                      Saat
                    </Label>
                    <Input
                      id="schedule-time"
                      type="time"
                      value={scheduledTime}
                      onChange={(e) => setScheduledTime(e.target.value)}
                      className="col-span-3"
                    />
                  </div>
                </div>
                <DialogFooter>
                  <DialogClose asChild>
                    <Button variant="outline">İptal</Button>
                  </DialogClose>
                  <Button onClick={handleSchedulePublication} disabled={isPending || !scheduledDate || !scheduledTime}>
                    {isPending ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : null}
                    Zamanla
                  </Button>
                </DialogFooter>
              </DialogContent>
            </Dialog>
          </>
        )}
        <AlertDialog>
          <AlertDialogTrigger asChild>
            <Button variant="destructive" disabled={isPending}>
              {isPending && !story.status /* if it's being deleted */ ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <Trash2 className="mr-2 h-4 w-4" />}
              Sil
            </Button>
          </AlertDialogTrigger>
          <AlertDialogContent>
            <AlertDialogHeader>
              <AlertDialogTitle>Bu hikayeyi silmek istediğinize emin misiniz?</AlertDialogTitle>
              <AlertDialogDescription>
                Bu işlem geri alınamaz. Bu, "{story.title}" başlıklı hikayeyi kalıcı olarak silecek.
              </AlertDialogDescription>
            </AlertDialogHeader>
            <AlertDialogFooter>
              <AlertDialogCancel>İptal</AlertDialogCancel>
              <AlertDialogAction onClick={handleDelete} className="bg-destructive hover:bg-destructive/90">
                Evet, hikayeyi sil
              </AlertDialogAction>
            </AlertDialogFooter>
          </AlertDialogContent>
        </AlertDialog>
      </CardFooter>
    </Card>
  );
}
