
// This is an autogenerated file from Firebase Studio.
'use server';

import type { Story, StoryGenre, ScheduledGeneration, WeeklyScheduleItem, DayOfWeek } from '@/lib/types';
import type { StoryLength, StoryComplexity } from '@/lib/constants';


import { generateStory as aiGenerateStory } from '@/ai/flows/generate-story';
import { regenerateAIImage as aiRegenerateAIImage } from '@/ai/flows/generate-image';

// Client components will call mock-db functions directly for localStorage modifications.
// Server actions are now primarily for:
// 1. AI interactions (which must run server-side).
// 2. Data validation/preparation before client handles localStorage.
// 3. Reading data if a server component needs it (though prefer client for localStorage consistency).

export async function publishStoryAction(storyId: string) {
  console.warn("publishStoryAction (server): Client should handle localStorage update. This action now only returns data for the client to act upon.");
  // const story = await dbGetStoryById(storyId); // Server actions shouldn't directly access client localStorage
  // if (!story) return { success: false, error: 'Hikaye bulunamadı (sunucu okuma)' };
  
  return { 
      success: true, 
      storyDataToUpdate: { 
          id: storyId, 
          status: 'published' as 'published', 
          publishedAt: new Date().toISOString(),
          scheduledAtDate: undefined, 
          scheduledAtTime: undefined 
      } 
  };
}

export async function deleteStoryAction(storyId: string) {
  console.warn("deleteStoryAction (server): Client should handle localStorage deletion. This action only returns an ID for the client.");
  return { success: true, storyIdToDelete: storyId }; 
}

export async function updateStoryCategoryAction(storyId: string, newGenre: StoryGenre) {
  console.warn("updateStoryCategoryAction (server): Client should handle localStorage update. This action returns data for client update.");
  return { success: true, storyDataToUpdate: { id: storyId, genre: newGenre } };
}


export async function generateNewStoryAction(
  genre: StoryGenre, 
  length?: StoryLength, 
  complexity?: StoryComplexity
): Promise<{ success: boolean; storyData?: Omit<Story, 'id' | 'summary' | 'createdAt'> & {status: 'pending'}; error?: string, story?: Story }> {
  try {
    console.log(`[Action] generateNewStoryAction: Generating story for genre: ${genre}, length: ${length}, complexity: ${complexity}`);
    const aiResult = await aiGenerateStory({ genre, length, complexity });
    console.log(`[Action] generateNewStoryAction: AI result received: Title: ${aiResult?.title ? 'Yes' : 'No'}, Content: ${aiResult?.content ? 'Yes' : 'No'}, ImageUrl: ${aiResult?.imageUrl ? 'Yes' : 'No'}`);

    if (!aiResult || !aiResult.title || !aiResult.content || !aiResult.imageUrl) {
      console.error("[Action] generateNewStoryAction: AI did not return expected title, content, or imageUrl.", aiResult);
      let specificError = 'Yapay zeka hikaye başlığı, içeriği veya görseli oluşturamadı.';
      if (!aiResult?.title) specificError += ' Başlık eksik.';
      if (!aiResult?.content) specificError += ' İçerik eksik.';
      if (!aiResult?.imageUrl) specificError += ' Görsel URL eksik.';
      throw new Error(specificError);
    }

    // Prepare the story data that will be returned to the client to add to localStorage
    const newStoryData: Omit<Story, 'id' | 'summary' | 'createdAt'> & {status: 'pending'} = {
      title: aiResult.title,
      content: aiResult.content,
      imageUrl: aiResult.imageUrl, 
      genre: genre,
      status: 'pending', 
      // length and complexity are not part of the Story type, so not included here
      // If they were, they would be:
      // length: length, 
      // complexity: complexity,
    };
    console.log(`[Action] generateNewStoryAction: Story data prepared successfully for genre: ${genre}`);
    // The actual Story object (with id, summary, createdAt) will be created client-side by mock-db.ts's addStory
    return { success: true, storyData: newStoryData };
  } catch (error) {
    console.error(`[Action] generateNewStoryAction: Error generating new story for genre ${genre}:`, error);
    let errorMessage = 'Yapay zeka ile hikaye oluşturulamadı.';
    if (error instanceof Error) {
        errorMessage = error.message;
    } else if (typeof error === 'string') {
        errorMessage = error;
    }
    // @ts-ignore
    if (error?.details?.code === 'ABORTED' && error?.details?.message?.includes('SafetyPolicyViolation')) {
      errorMessage = 'Hikaye üretimi güvenlik politikalarını ihlal ettiği için engellendi. Lütfen farklı bir tür veya konu deneyin.';
    }
    // @ts-ignore
    else if (error?.cause?.code === 'blocked' && error?.cause?.message?.includes('SAFETY')) {
        errorMessage = 'Hikaye üretimi güvenlik filtreleri tarafından engellendi. İçerik uygunsuz olabilir.';
    }
    
    return { success: false, error: errorMessage };
  }
}

export async function regenerateStoryImageAction(storyId: string, storyText: string): Promise<{ success: boolean; imageUrl?: string; storyIdToUpdate?: string; error?: string }> {
  try {
    const aiResult = await aiRegenerateAIImage({ storyText });
    if (!aiResult.imageUrl) {
      throw new Error('Yapay zeka yeni bir görsel URLsi oluşturamadı.');
    }
    return { success: true, imageUrl: aiResult.imageUrl, storyIdToUpdate: storyId };
  } catch (error) {
    console.error("[Action] regenerateStoryImageAction: Error regenerating image:", error);
    return { success: false, error: error instanceof Error ? error.message : 'Görsel yeniden oluşturulamadı' };
  }
}

export async function scheduleStoryPublicationAction(storyId: string, date: string, time: string): Promise<{ success: boolean; storyDataToUpdate?: Partial<Story> & { id: string }; error?: string }> {
  console.warn("scheduleStoryPublicationAction (server): Client handles localStorage update. This action returns data for client update.");
  return { 
    success: true, 
    storyDataToUpdate: { 
      id: storyId, 
      scheduledAtDate: date, 
      scheduledAtTime: time, 
      status: 'pending' 
    } 
  };
}

export async function scheduleStoryGenerationAction(
  scheduledDate: string, 
  scheduledTime: string, 
  genre: StoryGenre
): Promise<{ 
  success: boolean; 
  newScheduledGenerationData?: Omit<ScheduledGeneration, 'id' | 'status' | 'createdAt'>;
  error?: string 
}> {
  console.warn("scheduleStoryGenerationAction (server): Client will handle localStorage addition. This action only returns data for the client.");
  try {
    if (!scheduledDate || !scheduledTime || !genre) {
      return { success: false, error: "Lütfen tarih, saat ve tür bilgilerini eksiksiz girin." };
    }
    const newScheduledGenerationData: Omit<ScheduledGeneration, 'id' | 'status' | 'createdAt'> = {
      scheduledDate,
      scheduledTime,
      genre
    };
    return { success: true, newScheduledGenerationData };
  } catch (e) {
    const error = e instanceof Error ? e.message : "Planlama sırasında bir hata oluştu (sunucu).";
    console.error("[Action] scheduleStoryGenerationAction: Error:", error);
    return { success: false, error };
  }
}

export async function processScheduledGenerationAction(id: string, genre: StoryGenre): Promise<{ 
  success: boolean; 
  storyData?: Omit<Story, 'id' | 'summary' | 'createdAt'> & {status: 'pending'}; // Data for the new story
  error?: string; 
  scheduledGenerationId: string; // ID of the scheduled item to update its status
}> {
  console.log(`[Action] processScheduledGenerationAction: Processing ID: ${id} for Genre: ${genre}`);
  
  try {
    // For scheduled generations, we'll use default length and complexity for now.
    // This could be extended in the future if ScheduledGeneration type stores these.
    const generationResult = await generateNewStoryAction(genre, undefined, undefined);

    if (generationResult.success && generationResult.storyData) {
      console.log(`[Action] processScheduledGenerationAction: Story generated successfully for ID: ${id}, Genre: ${genre}`);
      return { 
        success: true, 
        storyData: generationResult.storyData, 
        scheduledGenerationId: id,
      };
    } else {
      console.error(`[Action] processScheduledGenerationAction: Story generation failed for ID: ${id}. Error: ${generationResult.error}`);
      return { 
        success: false, 
        error: generationResult.error || "Hikaye üretilemedi (alt eylem başarısız).", 
        scheduledGenerationId: id,
      };
    }
  } catch (e) {
    const errorMsg = e instanceof Error ? e.message : "Planlanmış üretim işlenirken beklenmedik bir sunucu hatası oluştu.";
    console.error(`[Action] processScheduledGenerationAction: Catch block error for ID: ${id}:`, e);
    return { 
      success: false, 
      error: errorMsg, 
      scheduledGenerationId: id,
    };
  }
}

export async function deleteScheduledGenerationAction(id: string): Promise<{ success: boolean; error?: string; scheduledGenerationIdToDelete?: string }> {
  console.warn("deleteScheduledGenerationAction (server): Client handles localStorage deletion. This action returns ID for client.");
  return { success: true, scheduledGenerationIdToDelete: id };
}

export async function getWeeklySchedulesAction(): Promise<{ success: boolean; schedules?: WeeklyScheduleItem[]; error?: string; }> {
  console.warn("getWeeklySchedulesAction (server): Client reads from localStorage. This action should primarily be for server-side data fetching if needed, returning empty for localStorage.");
  return { success: true, schedules: [] }; 
}

export async function saveWeeklyScheduleSlotAction(
  dayOfWeek: DayOfWeek, 
  time: string, 
  genre: StoryGenre | null
): Promise<{ 
  success: boolean; 
  slotToSave?: { dayOfWeek: DayOfWeek; time: string; genre: StoryGenre | null }; 
  error?: string; 
}> {
  console.warn("saveWeeklyScheduleSlotAction (server): Client will handle localStorage update. This action only returns data for the client.");
  try {
    if (genre && !["Korku", "Macera", "Romantik", "Bilim Kurgu", "Fabl", "Felsefi"].includes(genre)) {
        return { success: false, error: "Geçersiz tür." };
    }
    return { success: true, slotToSave: { dayOfWeek, time, genre } };
  } catch (e) {
    const error = e instanceof Error ? e.message : "Haftalık plan kaydedilirken bir sunucu hatası oluştu.";
    console.error("[Action] saveWeeklyScheduleSlotAction: Error:", error);
    return { success: false, error };
  }
}

    
